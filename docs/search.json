[{"path":"/articles/analysis.html","id":"initialisation","dir":"Articles","previous_headings":"","what":"Initialisation","title":"Penalised regression with multiple sources of prior effects","text":"Choose directory containing sub-directories “data”, “results” “manuscript”. directory “data” contain file “data/pone.0181468.s001.csv” second external application files “vcf_with_pvalue.tab” “LuxPark_pheno.txt” internal application. also contain file “app_int_data.RData” internal application. directory “results” contain files “sim_int.RData” “sim_ext.RData” external internal simulation, file “app_grridge.RData” first external application, file “app_fwelnet.RData” second external application, file “app_int.RData” internal application. directory “manuscript” contain files “table_int.tex” “table_ext.tex” internal external simulations, file “figure_example.pdf” methods section, file “figure_ext.pdf” external applications, file “figure_int.pdf” internal application. Install missing R packages CRAN GitHub. Note ecpc transreg also available CRAN. package versions, see session information end document text files associated R data file.","code":"rm(list=ls()) dir <- \"~/Desktop/transreg\" # physical machine #dir <- \"/home/armin.rauschenberger/transreg\" # virtual machine setwd(dir) if(!all(c(\"data\",\"results\",\"manuscript\") %in% dir())){  stop(\"Missing folders!\")  } knitr::opts_chunk$set(eval=TRUE,echo=TRUE) pkgs <- c(\"devtools\",\"palasso\",\"glmtrans\",\"xtable\") utils::install.packages(setdiff(pkgs,rownames(installed.packages()))) pkgs <- c(\"kjytay/fwelnet\",\"Mirrelijn/ecpc/Rpackage\",\"rauschenberger/transreg\") remotes::install_github(pkgs) rm(pkgs)"},{"path":"/articles/analysis.html","id":"methods","dir":"Articles","previous_headings":"","what":"Methods","title":"Penalised regression with multiple sources of prior effects","text":"Generate figure methods section.","code":"#<<init>> grDevices::pdf(file=paste0(dir,\"/manuscript/figure_example.pdf\"),width=8,height=5,pointsize=15)  set.seed(1) n <- 200; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) temp <- stats::rnorm(p) range <- stats::qnorm(p=c(0.01,0.99)) temp[temp<range[1]] <- range[1] temp[temp>range[2]] <- range[2]  beta <- list() beta$ident <- temp beta$sqrt <- sign(temp)*sqrt(abs(temp)) beta$quad <- sign(temp)*abs(temp)^2 beta$trunc <- ifelse(temp<=0,0,temp) beta$step <- ifelse(temp<=1,0,1) beta$combn <- ifelse(temp<0,sign(temp)*sqrt(abs(temp)),sign(temp)*abs(temp)^2)  graphics::par(mfrow=c(2,3),mar=c(3,3,0.5,0.5)) for(i in seq_along(beta)){      prior <- matrix(temp,ncol=1)   eta <- X %*% beta[[i]]   y <- stats::rnorm(n=n,mean=eta,sd=sd(eta))   a <- transreg:::.exp.multiple(y=y,X=X,prior=prior,family=\"gaussian\",select=FALSE)   b <- transreg:::.iso.fast.single(y=y,X=X,prior=prior,family=\"gaussian\")    graphics::plot.new()   graphics::plot.window(xlim=range(prior,-prior),ylim=range(a$beta,b$beta))   graphics::axis(side=1)   graphics::axis(side=2)   graphics::abline(h=0,lty=2,col=\"grey\")   graphics::abline(v=0,lty=2,col=\"grey\")   graphics::box()   graphics::title(xlab=expression(z),ylab=expression(gamma),line=2)   graphics::points(x=prior,y=a$beta,col=\"red\",cex=0.7)   graphics::points(x=prior,y=b$beta,col=\"blue\",cex=0.7)   graphics::lines(x=prior[order(prior)],y=beta[[i]][order(prior)],lwd=1.2)   graphics::legend(x=\"topleft\",legend=paste0(\"(\",i,\")\"),bty=\"n\",x.intersp=0) }  grDevices::dev.off() ## agg_png  ##       2"},{"path":"/articles/analysis.html","id":"simulations","dir":"Articles","previous_headings":"","what":"Simulations","title":"Penalised regression with multiple sources of prior effects","text":"Perform internal external simulation study. Execution time: several minutes. Generate  tables external internal simulation. Requires execution previous chunk.","code":"#<<init>>  # - - - modify glmtrans::models function - - - glmtrans.models <- glmtrans::models string <- base::deparse(glmtrans.models) # return target beta string <- gsub(pattern=\"list\\\\(x \\\\= NULL, y \\\\= NULL\\\\)\",                replacement=\"list(x = NULL, y = NULL, beta = wk)\",                x=string) # return source beta string <- gsub(pattern=\"list\\\\(x \\\\= x, y \\\\= y\\\\)\",                replacement=\"list(x = x, y = y, beta = wk)\",                x=string) glmtrans.models <- eval(parse(text=string)) rm(string) # - - - - - - - - - - - - - - - - - - - - - -  for(mode in c(\"ext\",\"int\")){        # simulation setting     if(mode==\"ext\"){       frame <- expand.grid(Ka=as.integer(c(1,3,5)),                            K=as.integer(5),                            h=as.integer(c(5,250)),                            alpha=as.integer(c(0,1)),                            family=c(\"gaussian\",\"binomial\"))       frame$seed <- rep(1:4,each=6)     } else if(mode==\"int\"){       frame <- expand.grid(rho.x=c(0.95,0.99),                            rho.beta=c(0.70,0.85,0.99),                            alpha=as.integer(c(0,1)),                            family=c(\"gaussian\",\"binomial\"))       frame$seed <- 1:24     }     frame$family <- as.character(frame$family)     frame[,c(\"cor.x\",\"cor.beta\",\"mean\",\"glmnet\",\"glmtrans\",\"transreg\")] <- NA     p <- 1000; n0 <- 100; n1 <- 10000     n.target <- n0+n1     foldid.ext <- rep(c(0,1),times=c(n0,n1))          for(iter in seq_len(nrow(frame))){              if(!is.na(frame$seed[iter])){set.seed(frame$seed[iter])}       #alpha <- frame$alpha[iter]        #family <- as.character(frame$family[iter])       #rho.beta <- frame$rho.beta[iter]              # data simulation       if(mode==\"ext\"){          message(\"Using external simulation study!\")         s <- ifelse(frame$alpha[iter]==0,50,15)         data <- glmtrans.models(family=frame$family[iter],type=\"all\",                                 p=p,n.target=n.target,s=s,                                 Ka=frame$Ka[iter],K=frame$K[iter],h=frame$h[iter])         target <- data$target         source <- data$source         beta <- cbind(sapply(data$source,function(x) x$beta),data$target$beta)       } else if(mode==\"int\"){         message(\"Using internal simulation study!\")         prop <- ifelse(frame$alpha[iter]==0,0.2,0.05)         data <- transreg:::simulate(p=p,n.target=n.target,family=frame$family[iter],                                 prop=prop,rho.beta=frame$rho.beta[iter],w=0.5,                                 rho.x=frame$rho.x[iter],k=3,exp=c(1,2,0.5),                                 trans=c(FALSE,TRUE,TRUE))         target <- data$target         source <- data$source         beta <- data$beta       }              # correlation       temp <- abs(stats::cor(data$target$x,method=\"pearson\"))       temp[lower.tri(temp,diag=TRUE)] <- NA       frame$cor.x[iter] <- mean(temp,na.rm=TRUE)       temp <- abs(stats::cor(beta,method=\"pearson\"))       temp[lower.tri(temp,diag=TRUE)] <- NA       frame$cor.beta[iter] <- max(temp[,ncol(temp)],na.rm=TRUE)              # predictive performance       loss <- transreg:::compare(target=target,source=source,                           family=frame$family[iter],alpha=frame$alpha[iter],                           foldid.ext=foldid.ext,nfolds.ext=1,                           scale=c(\"exp\",\"iso\"),                           sign=FALSE,switch=FALSE,select=TRUE,alpha.prior=NULL,                           seed=frame$seed[iter])       frame[iter,names(loss$deviance)] <- loss$deviance     }     save(frame,file=paste0(dir,\"/results/sim_\",mode,\".RData\"))) } writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_sim.txt\"))  #colMeans(frame[,paste0(\"transreg.\",c(\"exp\",\"iso\"),\".sta\")],na.rm=TRUE) #colMeans(frame[,paste0(\"transreg.\",c(\"exp\",\"iso\"),\".sim\")],na.rm=TRUE)  #stats::wilcox.test(x=frame$glmtrans,y=frame$transreg,alternative=\"greater\")  #load(\"results/sim_int.RData\") #load(\"results/sim_ext.RData\")  #data <- frame[c(\"mean\",\"glmnet\",\"glmtrans\",\"stage\",\"transreg\")]/frame$mean #cbind(frame$family,frame$alpha,frame$K,round(100*data,digits=0)) #colMeans(data) #apply(data,2,median) .table <- function(loss,info=NULL,hline=NULL,pvalue=NULL,caption=\"\",file=\"\"){   loss[is.na(loss)] <- Inf      if(nrow(loss)>5){   quote <- NA*loss   quote[1,] <- FALSE   quote[2,] <- loss[1,]==loss[2,] & loss[1,]==loss[3,] & loss[1,]==loss[4,]   quote[3,] <- loss[2,]==loss[3,] & loss[3,]==loss[4,] & loss[4,]==loss[5,]   for(i in 4:(nrow(loss)-1)){     quote[i,] <- (loss[i,]==loss[i-1,] & loss[i,]==loss[i-2,] & loss[i,]==loss[i-3,]) |        (loss[i,]==loss[i-1,] & loss[i,]==loss[i+1,] & loss[i,]==loss[i+2,])   }   quote[nrow(quote),] <- loss[nrow(quote),]==loss[nrow(quote)-1,] &           loss[nrow(quote),]==loss[nrow(quote)-2,] &           loss[nrow(quote),]==loss[nrow(quote)-3,]   }      loss <- round(loss,digits=3)       min <- cbind(seq_len(nrow(loss)),apply(loss,1,which.min))   pos <- loss >= 0   leq <- loss >= loss[,\"glmnet\"]   loss <- format(round(loss,digits=3),digits=3)   if(nrow(loss)>5){loss[quote==1] <- \"\\\"\"}   loss[leq] <- paste0(\"\\\\textcolor{gray}{\",loss[leq],\"}\")   loss[min] <- paste0(\"\\\\underline{\",loss[min],\"}\")   loss[pos] <- paste0(\"~\",loss[pos])   colnames(loss) <- paste0(\"\\\\texttt{\",colnames(loss),\"}\")   rownames(loss) <- paste0(\"\\\\textsc{\",tolower(rownames(loss)),\"}\")      if(is.null(info)){     table <- loss     align <- paste0(\"|r|\",paste0(rep(\"r\",times=ncol(loss)),collapse=\"\"),\"|\")     include.rownames <- TRUE   } else {     info[is.na(info)] <- \"-\"     table <- cbind(info,loss)     align <- paste0(\"|r|\",paste0(rep(\"r\",times=ncol(info)),collapse=\"\"),\"|\",                     paste0(rep(\"r\",times=ncol(loss)),collapse=\"\"),\"|\")     include.rownames <- FALSE   }   xtable <- xtable::xtable(x=table,caption=caption,align=align)   xtable::print.xtable(x=xtable,                        sanitize.text.function=identity,                        include.rownames=include.rownames,                        floating=TRUE,                        comment=FALSE,                        hline.after=c(-1,0,hline,nrow(table)),                        caption.placement=\"top\",                        file=file) }  for(mode in c(\"ext\",\"int\")){     file <- paste0(dir,\"/results/sim_\",mode,\".RData\")     if(!file.exists(file)){warning(\"Missing file \",file,\".\");next}     load(file)     cond <- colnames(frame) %in% c(\"Ka\",\"h\",\"rho.x\",\"rho.beta\",\"cor.x\",\"cor.beta\",\"cor.t\",\"alpha\",\"family\")     info <- frame[,cond]     info <- info[,colMeans(is.na(info))<1]     colnames(frame) <- gsub(pattern=\"transreg.\",replacement=\"\",x=colnames(frame))     #colnames(frame) <- gsub(pattern=\"_\",replacement=\".\",x=colnames(frame))     names <- c(\"mean\",\"glmnet\",\"glmtrans\",\"exp.sta\",\"exp.sim\",\"iso.sta\",\"iso.sim\")     loss <- frame[,names]     loss <- round(100*loss/loss$mean,digits=1)     loss <- loss[,!colnames(loss) %in% \"mean\"]     colnames(info) <- sapply(colnames(info),function(x) switch(x,\"Ka\"=\"$K_a$\",\"K\"=\"$K$\",\"h\"=\"$h$\",\"alpha\"=\"$\\\\alpha$\",\"rho.x\"=\"$\\\\rho_x$\",\"rho.beta\"=\"$\\\\rho_\\\\beta$\",\"cor.x\"=\"$\\\\color{blue}\\\\bar{\\\\rho}_{x}$\",\"cor.beta\"=\"$\\\\color{blue}\\\\max(\\\\hat{\\\\rho}_{\\\\beta})$\",\"cor.t\"=\"$\\\\color{blue}{\\\\bar{\\\\rho}_{a}}$\",x))     external <- \"number of transferable source data sets ($K_a$), differences between source and target coefficients ($h$), dense setting with ridge regularisation ($s=50$, $\\\\alpha=0$) or sparse setting with lasso regularisation ($s=15$, $\\\\alpha=1$), family of distribution (`gaussian' or `binomial').\"     internal <- \"correlation \\\\textcolor{blue}{parameter for} features ($\\\\rho_x$), correlation \\\\textcolor{blue}{parameter for} coefficients ($\\\\rho_{\\\\beta}$), dense setting with ridge regularisation ($\\\\pi=\\\\textcolor{blue}{20}\\\\%$, $\\\\alpha=0$) or sparse setting with lasso regularisation ($\\\\pi=\\\\textcolor{blue}{5}\\\\%$, $\\\\alpha=1$), family of distribution (`gaussian' or `binomial').\"     caption <- paste0(\"Testing loss in \",mode,\"ernal simulation\\\\textcolor{blue}{, as a percentage of the one from prediction by the mean}. Settings: \",ifelse(mode==\"ext\",external,ifelse(mode==\"int\",internal,NULL)),\" \\\\textcolor{blue}{These parameters determine (i) the average Pearson correlations among the features in the target data set ($\\\\bar{\\\\rho}_x$) and (ii) the maximum Pearson correlation between the coefficients in the target data set and the coefficients in the source data sets ($\\\\max(\\\\hat{\\\\rho}_{\\\\beta})$).} Methods: \\\\textcolor{blue}{\\\\sout{prediction by the mean,}} regularised regression (\\\\texttt{glmnet}), competing transfer learning method (\\\\texttt{glmtrans}), proposed transfer learning method (\\\\texttt{transreg}) with exponential/isotonic calibration and \\\\textcolor{blue}{standard}/\\\\textcolor{blue}{simultaneous} stacking. In each setting, the colour black highlights methods that are more predictive than \\\\textcolor{blue}{\\\\sout{prediction by the mean} regularised regression without transfer learning (\\\\texttt{glmnet})}, and an underline highlights the most predictive method. \\\\label{sim_\",mode,\"}\")     .table(info=info,loss=loss,caption=caption,file=paste0(dir,\"/manuscript/table_\",mode,\".tex\")) }"},{"path":"/articles/analysis.html","id":"external-applications","dir":"Articles","previous_headings":"","what":"External applications","title":"Penalised regression with multiple sources of prior effects","text":"Perform first external application. Execution time: several minutes. Perform second external application. Execution time: several minutes. Generate figure external applications. Requires execution previous two chunks.","code":"#<<init>> data(dataVerlaat,package=\"GRridge\")  target <- list() target$y <- as.numeric(as.factor(respVerlaat))-1 target$x <- t(datcenVerlaat)  z <- -log10(pvalFarkas) # ecpc and fwelnet prior <- sign(diffmeanFarkas)*(-log10(pvalFarkas)) # transreg  loss <- list() for(i in 1:10){   cat(\"---\",i,\"---\\n\")   loss[[i]] <- transreg:::compare(target=target,prior=prior,z=as.matrix(z,ncol=1),                                     family=\"binomial\",alpha=0,scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,monotone=NULL,partitions=NULL,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=i) } save(loss,file=paste0(dir,\"/results/app_grridge.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_grridge.txt\"))  load(paste0(dir,\"/results/app_grridge.RData\"),verbose=TRUE) table <- as.data.frame(t(sapply(loss,function(x) x$deviance))) table <- (table-table$glmnet)/table$glmnet table <- table[,c(\"glmnet\",\"transreg.exp.sta\",\"transreg.exp.sim\",\"transreg.iso.sta\",\"transreg.iso.sim\",\"fwelnet\",\"ecpc\")] sapply(table[,-1],function(x) sum(x<table$glmnet)) round(100*colMeans(table[,-1]),digits=2) table <- utils::read.csv(\"data/pone.0181468.s001.csv\",header=TRUE,skip=3)  extract <- function(cond,y,X,id){   if(length(unique(c(length(cond),length(y),nrow(X),length(id))))!=1){stop(\"Invalid input.\")}   n <- table(id,cond)[,\"TRUE\"]   y <- y[cond]   X <- X[cond,]   id <- id[cond]   weights <- rep(1/n,times=n)   ids <- unique(id)   ys <- sapply(ids,function(x) unique(y[id==x]))   foldid <- rep(NA,length=length(ids))   foldid[ys==0] <- sample(rep(1:10,length.out=sum(ys==0)))   foldid[ys==1] <- sample(rep(1:10,length.out=sum(ys==1)))   foldid <- rep(foldid,times=n[n!=0])   if(length(unique(c(length(y),nrow(X),length(weights),length(foldid))))!=1){     stop(\"Invalid output.\")   }   return(list(y=y,x=X,weights=weights,foldid=foldid)) }  loss <- ridge <- lasso <- list() for(i in 1:10){   cat(\"---\",i,\"---\\n\")   set.seed(i)      y <- table$LatePE   X <- as.matrix(table[,grepl(pattern=\"SL\",x=colnames(table))])   X <- scale(X)      min <- sapply(unique(table$ID),function(i) min(table$GA[table$ID==i]))   max <- sapply(unique(table$ID),function(i) max(table$GA[table$ID==i]))      limit <- 20   group <- stats::rbinom(n=max(table$ID),size=1,prob=0.5)   source.id <- which(group==0 | min > limit)   target.id <- which(group==1 & min <= limit)   if(any(!table$ID %in% c(source.id,target.id))){stop()}   if(any(!c(source.id,target.id) %in% table$ID)){stop()}   if(any(duplicated(c(source.id,target.id)))){stop()}      source <- list()   source[[1]] <- extract(cond=(table$ID %in% source.id) & (table$GA<=limit),y=y,X=X,id=table$ID)   source[[2]] <- extract(cond=(table$ID %in% source.id),y=y,X=X,id=table$ID)      prior <- z <- matrix(NA,nrow=ncol(X),ncol=length(source))   for(j in seq_along(source)){     base <- glmnet::cv.glmnet(y=source[[j]]$y,x=source[[j]]$x,                               family=\"binomial\",alpha=0,                               weights=source[[j]]$weights,                               foldid=source[[j]]$foldid)     prior[,j] <- coef(base,s=\"lambda.min\")[-1]     z[,j] <- abs(coef(base,s=\"lambda.min\")[-1])   }      target <- list()   target$y <- sapply(target.id,function(i) unique(y[table$ID==i]))   target$x <- t(sapply(target.id,function(i) X[table$ID==i & table$GA==min(table$GA[table$ID==i]),]))      loss[[i]] <- transreg:::compare(target=target,prior=prior,family=\"binomial\",alpha=0,scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,z=z,type.measure=c(\"deviance\",\"class\",\"auc\"),seed=i) } save(loss,file=paste0(dir,\"/results/app_fwelnet.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_fwelnet.txt\"))  load(paste0(dir,\"/results/app_fwelnet.RData\")) table <- as.data.frame(t(sapply(loss,function(x) x$deviance))) table <- (table-table$glmnet)/table$glmnet table <- table[,c(\"glmnet\",\"transreg.exp.sta\",\"transreg.exp.sim\",\"transreg.iso.sta\",\"transreg.iso.sim\",\"fwelnet\",\"ecpc\")] sapply(table[,-1],function(x) sum(x<table$glmnet)) round(100*colMeans(table[,-1]),digits=2) grDevices::pdf(file=paste0(dir,\"/manuscript/figure_ext.pdf\"),width=8,height=6,pointsize=15)  graphics::par(mfrow=c(2,1),mar=c(2.5,3.5,0.5,0.5))  for(k in c(\"grridge\",\"fwelnet\")){   file <- paste0(dir,\"/results/app_\",k,\".RData\")   if(!file.exists(file)){plot.new();next}   load(file)   loss <- as.data.frame(t(sapply(loss,function(x) x$deviance)))   colnames(loss) <- gsub(pattern=\"transreg.\",replacement=\"\",x=colnames(loss))   #colnames(loss) <- gsub(pattern=\"_\",replacement=\".\",x=colnames(loss))   loss <- 100*(loss-loss$glmnet)/loss$glmnet    temp <- c(\"exp.sta\",\"exp.sim\",\"iso.sta\",\"iso.sim\")   name <- c(\"fwelnet\",\"ecpc\",temp)   graphics::plot.new()   graphics::plot.window(xlim=c(0.5,length(name)+0.5),ylim=range(loss,na.rm=TRUE))   #graphics::abline(h=median(loss$mean),lty=2,col=\"grey\")   graphics::abline(h=0,lty=2,col=\"grey\")   graphics::axis(side=1,at=seq_along(name),labels=name,cex.axis=0.7)   if(grepl(pattern=\"grridge\",x=k)){at <- seq(from=-10,to=10,by=5)}   if(grepl(pattern=\"fwelnet\",x=k)){at <- seq(from=-20,to=20,by=10)}   labels <- ifelse(at==0,\"0%\",ifelse(at<0,paste0(at,\"%\"),paste0(\"+\",at,\"%\")))   graphics::axis(side=2,cex.axis=0.7,at=at,labels=labels)   graphics::title(ylab=\"change in loss\",line=2.5,cex.lab=0.7)   graphics::box()   for(i in seq_along(name)){     palasso:::.boxplot(loss[,name[i]],at=i,invert=FALSE)     graphics::points(x=i,y=mean(loss[,name[i]]),pch=22,col=\"white\",bg=\"black\",cex=0.7)   } }  grDevices::dev.off() ## agg_png  ##       2"},{"path":"/articles/analysis.html","id":"internal-application","dir":"Articles","previous_headings":"","what":"Internal application","title":"Penalised regression with multiple sources of prior effects","text":"Perform internal application. Execution time: several hours. Generate figure internal application. Requires execution previous chunk.","code":"#<<init>> geno <- read.table(\"data/vcf_with_pvalue.tab\",header=TRUE)  switch <- ifelse(geno$REF==geno$A1_gwas & geno$ALT==geno$A2_gwas,1,                  ifelse(geno$REF==geno$A2_gwas & geno$ALT==geno$A1_gwas,-1,0)) #prior <- log10(geno$p_value)*sign(geno$beta)*switch # pseudo effect sizes prior <- -geno$beta*switch # original effect sizes pvalue <- geno$p_value  X <- geno[,grepl(pattern=\"ND\",colnames(geno))] X[X==\"0/0\"] <- 0 X[X==\"0/1\"] <- 1 X[X==\"1/1\"] <- 1 X <- sapply(X,as.numeric) X <- t(X)  pheno <- read.delim(\"data/LuxPark_pheno.txt\",sep=\" \",header=FALSE) y <- ifelse(pheno$V2==1,0,ifelse(pheno$V2==2,1,NA)); names(y) <- pheno$V1  names <- intersect(names(y[!is.na(y)]),rownames(X)) X <- X[names,]; y <- y[names]  cor <- as.numeric(stats::cor(y,X)) graphics::plot(x=prior,y=cor)  save(y,X,prior,pvalue,switch,file=paste0(dir,\"/data/app_int_data.RData\"))  # descriptive statistics sum(p.adjust(pvalue,method=\"BH\")<=0.05) sum(p.adjust(pvalue,method=\"holm\")<=0.05) mean(pvalue<=0.05) dim(X) table(y)  load(paste0(dir,\"/data/app_int_data.RData\")) power <- seq(from=-2,to=-10,by=-1) cutoff <- 5*10^power frame <- expand.grid(cutoff=cutoff,alpha=0:1,seed=1:10,count=NA)  loss <- list() for(i in seq_len(nrow(frame))){   cat(\"--- i =\",i,\"---\",\"\\n\")   set.seed(frame$seed[i])   foldid <- transreg:::.folds(y=y,nfolds.ext=10,nfolds.int=10)   cond <- switch!=0 & pvalue < frame$cutoff[i]   loss[[i]] <- transreg:::compare(target=list(y=y,x=X[,cond]),prior=prior[cond],family=\"binomial\",alpha=frame$alpha[i],scale=c(\"exp\",\"iso\"),sign=FALSE,switch=FALSE,select=FALSE,foldid.ext=foldid$foldid.ext,foldid.int=foldid$foldid.int,type.measure=c(\"deviance\",\"class\",\"auc\")) # was without foldid.int   frame$count[i] <- sum(cond) } save(frame,loss,file=paste0(dir,\"/results/app_int.RData\")) writeLines(text=capture.output(utils::sessionInfo(),cat(\"\\n\"),       sessioninfo::session_info()),con=paste0(dir,\"/results/info_app_int.txt\"))  # use repeated 10-fold CV (TO DO) # modify function cv.transfer so that it accepts named list with \"y and X\" (not only \"y and x\") (TO DO) #<<init>> grDevices::pdf(file=paste0(dir,\"/manuscript/figure_int.pdf\"),width=8,height=6,pointsize=15)  load(paste0(dir,\"/results/app_int.RData\")) # TO DO: change this line frame <- frame[seq_along(loss),colnames(frame)!=\"seed\"] #foldid <- sapply(loss,function(x) x$foldid) #pred <- sapply(loss,function(x) x$pred) loss <- as.data.frame(t(sapply(loss,function(x) x$auc))) # temporary AUC #names(loss)[names(loss)==\"prs\"] <- \"naive\" # TO DO: delete this line  table <- lapply(loss,function(x) tapply(X=x,INDEX=list(frame$cutoff,frame$alpha),FUN=function(x) mean(x)))  cutoff <- unique(frame$cutoff) number <- unique(frame$count)  graphics::par(mfrow=c(2,2),mar=c(3,1.8,1.0,0.9)) for(scale in c(\"exp\",\"iso\")){   for(alpha in c(\"0\",\"1\")){     graphics::plot.new()     graphics::plot.window(xlim=range(log(cutoff)),ylim=range(table))     graphics::box()     graphics::title(main=paste(ifelse(alpha==0,\"ridge\",ifelse(alpha==1,\"lasso\",NA)),\"-\",scale),cex.main=1,line=0.2)     on <- rep(c(TRUE,FALSE),length.out=length(cutoff))     graphics::axis(side=1,at=log(cutoff),labels=rep(\"\",times=length(on)),cex.axis=0.7)     graphics::axis(side=1,at=log(cutoff)[on],labels=paste0(cutoff[on],\"\\n\",\"(\",number[on],\")\"),cex.axis=0.7)          graphics::axis(side=2,cex.axis=0.7)     #graphics::abline(h=unique(table[[\"mean\"]][,alpha]),col=\"grey\",lty=2)     graphics::abline(h=0.5,col=\"grey\",lty=2)     for(i in 1:3){     for(method in c(\"glmnet\",paste0(\"transreg.\",scale,c(\".sta\",\".sim\")),\"naive\")){       lty <- switch(method,\"mean\"=1,\"glmnet\"=1,\"transreg.exp.sta\"=2,\"transreg.exp.sim\"=2,\"transreg.iso.sta\"=2,\"transreg.iso.sim\"=2,\"naive\"=3)       col <- switch(method,\"mean\"=\"grey\",\"glmnet\"=\"black\",\"transreg.exp.sta\"=rgb(0.2,0.2,1),\"transreg.iso.sta\"=rgb(0.2,0.2,1),\"transreg.exp.sim\"=rgb(0,0,0.6),\"transreg.iso.sim\"=rgb(0,0,0.6),\"naive\"=\"red\")       y <- table[[method]][,alpha]       x <- log(as.numeric(names(y)))       #cond <- x >= log(5e-08)       if(i==1){graphics::lines(x=x,y=y,col=col,lty=lty)}       if(i==2){graphics::points(x=x,y=y,col=\"white\",pch=16)}       if(i==3){graphics::points(x=x,y=y,col=col)}     }     }   } }  grDevices::dev.off() ## agg_png  ##       2"},{"path":"/articles/analysis.html","id":"session-information","dir":"Articles","previous_headings":"Internal application","what":"Session information","title":"Penalised regression with multiple sources of prior effects","text":"Reformat list consortium members acknowledgements: [see source]. Print session information.","code":"utils::toLatex(utils::sessionInfo())"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Armin Rauschenberger. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rauschenberger (2022). transreg: Penalised regression multiple sets prior effects. R package version 0.0.1.","code":"@Manual{,   title = {transreg: Penalised regression with multiple sets of prior effects},   author = {Armin Rauschenberger},   year = {2022},   note = {R package version 0.0.1}, }"},{"path":"/index.html","id":"penalised-regression-with-multiple-sets-of-prior-effects","dir":"","previous_headings":"","what":"Penalised regression with multiple sets of prior effects","title":"Penalised regression with multiple sets of prior effects","text":"Improves predictive performance ridge lasso regression exploiting one sources prior information importance direction effects.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Penalised regression with multiple sets of prior effects","text":"Install current release CRAN: latest development version GitLab GitHub:","code":"#install.packages(\"transreg\") # not yet released! #install.packages(\"remotes\") remotes::install_gitlab(\"bds/cornet\",host=\"gitlab.lcsb.uni.lu\") remotes::install_github(\"rauschenberger/transreg\")"},{"path":"/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Penalised regression with multiple sets of prior effects","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). “Penalised regression multiple sets prior effects”. Manuscript preparation.","code":""},{"path":"/reference/calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — calibrate","title":"Internal functions — calibrate","text":"Internal functions called transreg(), depending choice exponential isotonic calibration.","code":""},{"path":"/reference/calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — calibrate","text":"","code":".exp.multiple(   y,   X,   prior,   family,   switch = FALSE,   select = TRUE,   track = FALSE )  .iso.multiple(   y,   X,   prior,   family,   switch = FALSE,   select = TRUE,   track = FALSE )  .iso.fast.single(y, X, prior, family)  .iso.slow.single(y, X, prior, family)"},{"path":"/reference/calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — calibrate","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); switch choose positive negative weights source: logical select select sources: logical track show intermediate output (messages plots): logical","code":""},{"path":"/reference/calibrate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — calibrate","text":".exp.multiple(): called transreg scale=\"exp\" .iso.multiple(): called transreg scale=\"iso\" .iso.fast.single(): called transreg scale=\"iso\" (via .iso.multiple) .iso.slow.single(): replaced .iso.fast.single","code":""},{"path":[]},{"path":"/reference/coef.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients — coef.lp","title":"Coefficients — coef.lp","text":"Extracts coefficients","code":""},{"path":"/reference/coef.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients — coef.lp","text":"","code":"# S3 method for lp coef(object, ...)  # S3 method for mf coef(object, ...)"},{"path":"/reference/coef.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients — coef.lp","text":"object object class 'transreg' ... (applicable)","code":""},{"path":"/reference/coef.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients — coef.lp","text":"","code":"NA #> [1] NA"},{"path":"/reference/coef.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Coefficients — coef.transreg","title":"Extract Coefficients — coef.transreg","text":"Extracts coefficients object class transreg.","code":""},{"path":"/reference/coef.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Coefficients — coef.transreg","text":"","code":"# S3 method for transreg coef(object, stack = NULL, ...)"},{"path":"/reference/coef.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Coefficients — coef.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/coef.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Coefficients — coef.transreg","text":"Returns estimated coefficients. output list two slots: slot alpha estimated intercept (scalar), slot beta estimated slopes (vector).","code":""},{"path":"/reference/coef.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract Coefficients — coef.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/coef.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Coefficients — coef.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- glmnet (without prior effects) --- object <- glmnet::cv.glmnet(y=y,x=X,alpha=0) beta_hat <- coef(object,s=\"lambda.min\")[-1] mean((beta-beta_hat)^2) #> [1] 0.8051971  #--- transreg (with prior effects) --- object <- transreg(y=y,X=X,prior=prior,alpha=0) beta_hat <- coef(object)$beta mean((beta-beta_hat)^2) # decrease in MSE? #> [1] 0.4545027"},{"path":"/reference/compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation (reproducibility) — compare","title":"Cross-validation (reproducibility) — compare","text":"Function reproducing hold-method (simulation) \\(k\\)-fold cross-validation (application). See vignette.","code":""},{"path":"/reference/compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation (reproducibility) — compare","text":"","code":"compare(   target,   source = NULL,   prior = NULL,   z = NULL,   family,   alpha,   scale = \"iso\",   sign = FALSE,   switch = FALSE,   select = TRUE,   foldid.ext = NULL,   nfolds.ext = 10,   foldid.int = NULL,   nfolds.int = 10,   type.measure = \"deviance\",   alpha.prior = NULL,   partitions = NULL,   monotone = NULL,   naive = TRUE,   diffpen = FALSE,   seed = NULL,   cores = 1 )"},{"path":"/reference/compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation (reproducibility) — compare","text":"target list slot x (feature matrix n rows p columns) slot y (target vector length n) source list k lists, slot x (feature matrix m_i rows p columns) slot y (target vector length m_i) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) z prior weights family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 scale character \"exp\" exponential calibration \"iso\" isotonic calibration sign sign discovery procedure: logical (experimental argument) switch choose positive negative weights source: logical select select sources: logical foldid.ext external fold identifiers nfolds.ext number external folds foldid.int internal fold identifiers nfolds.int number internal folds type.measure character alpha.prior alpha source regression partitions monotone: GRridge monotone logical naive compare naive transfer learning: logical diffpen differential penalisation features meta-features: logical (experimental argument) seed random seed cores number cores parallel computing (requires R package doMC)","code":""},{"path":[]},{"path":"/reference/compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation (reproducibility) — compare","text":"","code":"set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) y <- X %*% beta # \\dontshow{ object <- suppressMessages(transreg:::compare(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0))# } if (FALSE) { object <- transreg:::compare(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0)}"},{"path":"/reference/cv.transfer.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation — cv.transfer","title":"Cross-validation — cv.transfer","text":"Performs external \\(k\\)-fold cross-validation estimate predictive performance different methods.","code":""},{"path":"/reference/cv.transfer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation — cv.transfer","text":"","code":"cv.transfer(   target,   source = NULL,   prior = NULL,   z = NULL,   family,   alpha,   scale = \"iso\",   sign = FALSE,   select = TRUE,   switch = TRUE,   foldid.ext = NULL,   nfolds.ext = 10,   foldid.int = NULL,   nfolds.int = 10,   type.measure = \"deviance\",   alpha.prior = NULL,   partitions = NULL,   monotone = NULL,   naive = TRUE,   diffpen = FALSE )"},{"path":"/reference/cv.transfer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation — cv.transfer","text":"target list slot x (feature matrix n rows p columns) slot y (target vector length n) source list k lists, slot x (feature matrix m_i rows p columns) slot y (target vector length m_i) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) z prior weights family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 scale character \"exp\" exponential calibration \"iso\" isotonic calibration sign sign discovery procedure: logical select select sources: logical switch choose positive negative weights source: logical foldid.ext external fold identifiers nfolds.ext number external folds foldid.int internal fold identifiers nfolds.int number internal folds type.measure character alpha.prior alpha source regression partitions monotone: GRridge monotone logical naive compare naive transfer learning: logical diffpen differential penalisation features meta-features: logical","code":""},{"path":[]},{"path":"/reference/cv.transfer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation — cv.transfer","text":"","code":"n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) y <- X %*% beta # \\dontshow{ object <- suppressMessages(cv.transfer(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0))# } if (FALSE) { object <- cv.transfer(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0)}"},{"path":"/reference/dot-calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .calibrate","title":"Internal functions — .calibrate","text":"Internal functions called transreg(), depending choice exponential isotonic calibration.","code":""},{"path":"/reference/dot-calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — .calibrate","text":"plot logical","code":""},{"path":[]},{"path":"/reference/dot-coef.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"called by coef.transreg if stack=","title":"called by coef.transreg if stack=","text":"called coef.transreg stack=\"lp\"","code":""},{"path":"/reference/dot-coef.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by coef.transreg if stack=","text":"","code":".coef.lp(object, ...)"},{"path":"/reference/dot-coef.mf.html","id":null,"dir":"Reference","previous_headings":"","what":"called by coef.transreg if stack=","title":"called by coef.transreg if stack=","text":"called coef.transreg stack=\"mf\"","code":""},{"path":"/reference/dot-coef.mf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by coef.transreg if stack=","text":"","code":".coef.mf(object, ...)"},{"path":"/reference/dot-exp.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential scaling — .exp.multiple","title":"Exponential scaling — .exp.multiple","text":"Performs exponential scaling","code":""},{"path":"/reference/dot-exp.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential scaling — .exp.multiple","text":"","code":".exp.multiple(y, X, prior, family, select, plot = TRUE)"},{"path":"/reference/dot-exp.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential scaling — .exp.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical plot logical","code":""},{"path":[]},{"path":"/reference/dot-exp.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential scaling — .exp.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .extract","title":"Internal functions — .extract","text":"Internal functions called coef.transreg(), predict.transreg() weights.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":[]},{"path":"/reference/dot-iso.fast.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.fast.single","title":"Isotonic scaling — .iso.fast.single","text":"Performs isotonic scaling","code":""},{"path":"/reference/dot-iso.fast.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.fast.single","text":"","code":".iso.fast.single(y, X, prior, family)"},{"path":"/reference/dot-iso.fast.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.fast.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/dot-iso.fast.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.fast.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-iso.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.multiple","title":"Isotonic scaling — .iso.multiple","text":"Performs isotonic scaling","code":""},{"path":"/reference/dot-iso.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.multiple","text":"","code":".iso.multiple(y, X, prior, family, select = TRUE, switch = TRUE)"},{"path":"/reference/dot-iso.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical switch choose positive negative weights source: logical","code":""},{"path":[]},{"path":"/reference/dot-iso.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-iso.slow.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.slow.single","title":"Isotonic scaling — .iso.slow.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/dot-iso.slow.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.slow.single","text":"","code":".iso.slow.single(y, X, prior, family)"},{"path":"/reference/dot-iso.slow.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.slow.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/dot-iso.slow.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.slow.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .methods","title":"Internal functions — .methods","text":"Internal functions called coef.transreg() predict.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":[]},{"path":"/reference/dot-predict.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"called by predict.transreg if stack=","title":"called by predict.transreg if stack=","text":"called predict.transreg stack=\"lp\"","code":""},{"path":"/reference/dot-predict.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by predict.transreg if stack=","text":"","code":".predict.lp(object, newx, ...)"},{"path":"/reference/dot-predict.mf.html","id":null,"dir":"Reference","previous_headings":"","what":"called by predict.transreg if stack=","title":"called by predict.transreg if stack=","text":"called predict.transreg stack=\"mf\"","code":""},{"path":"/reference/dot-predict.mf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by predict.transreg if stack=","text":"","code":".predict.mf(object, newx, ...)"},{"path":"/reference/dot-residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — .residuals","title":"Calculate residuals — .residuals","text":"Calculates residuals observed outcome predicted values (Gaussian family) predicted probabilities (binomial family). Called .exp.multiple .iso.multiple.","code":""},{"path":"/reference/dot-residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — .residuals","text":"","code":".residuals(y, y_hat, family)"},{"path":"/reference/dot-residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — .residuals","text":"y response: vector length \\(n\\) (see family) y_hat predicted values probabilities (see family): vector length \\(n\\), matrix \\(n\\) rows (samples) \\(k\\) columns (methods) family character \"gaussian\" (\\(y\\): real numbers, \\(y_hat\\): real numbers) \"binomial\" (\\(y\\): 0s 1s, \\(y_hat\\): unit interval)","code":""},{"path":"/reference/dot-residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate residuals — .residuals","text":"","code":"n <- 100 p <- 5 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) #y <- stats::rbinom(n,size=1,prob=0.5) y <- stats::rnorm(n) glm <- glm(y~X,family=\"gaussian\") res <- residuals.glm(glm) y_hat <- predict(glm,type=\"response\") all.equal(res,y-y_hat) #> [1] TRUE"},{"path":"/reference/dot-signdisc.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign discovery — .signdisc","title":"Sign discovery — .signdisc","text":"Assigns signs prior weights obtain prior coefficients","code":""},{"path":"/reference/dot-signdisc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign discovery — .signdisc","text":"","code":".signdisc(y, X, prior, family, foldid = NULL, nfolds = 10, track = FALSE)"},{"path":"/reference/dot-signdisc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign discovery — .signdisc","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer track show intermediate output (messages plots): logical","code":""},{"path":"/reference/dot-signdisc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sign discovery — .signdisc","text":"","code":"n <- 100; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) beta <- stats::rnorm(p)*stats::rbinom(n=p,size=1,prob=0.2) y <- X %*% beta prior <- matrix(abs(beta),ncol=1) #temp <- .signdisc(y,X,prior,family=\"gaussian\") #table(sign(beta),sign(temp))"},{"path":"/reference/dot-simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation — .simulate","title":"Simulation — .simulate","text":"Simulates data","code":""},{"path":"/reference/dot-simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation — .simulate","text":"","code":".simulate(   p = 1000,   n.target = 100,   n.source = 150,   k = 3,   family = \"gaussian\",   prop = 0.01,   rho.beta = 0.95,   rho.x = 0.95,   w = 0.5 )"},{"path":"/reference/dot-simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation — .simulate","text":"p number features n.target sample size target data set n.source sample size(s) source data set(s), scalar vector length k k number source data sets family \"Gaussian\", \"binomial\" \"poisson\" prop approximate proportion features effects rho.beta correlation effects (across different data sets) rho.x base decreasing correlation structure correlation features w weight signal noise","code":""},{"path":"/reference/dot-simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation — .simulate","text":"","code":"NA #> [1] NA"},{"path":"/reference/exp.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential scaling — exp.multiple","title":"Exponential scaling — exp.multiple","text":"Performs exponential scaling","code":""},{"path":"/reference/exp.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential scaling — exp.multiple","text":"","code":"# S3 method for multiple exp(y, X, prior, family, select, plot = TRUE)"},{"path":"/reference/exp.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential scaling — exp.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical plot logical","code":""},{"path":"/reference/exp.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential scaling — exp.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — extract","title":"Internal functions — extract","text":"Internal functions called coef.transreg(), predict.transreg() weights.transreg(), depending choice standard stacking simultaneous stacking.","code":""},{"path":"/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — extract","text":"","code":".predict.sta(object, newx, ...)  .predict.sim(object, newx, ...)  .coef.sta(object, ...)  .coef.sim(object, ...)  .weights.sta(object, ...)  .weights.sim(object, ...)  .which.stack(object, stack)"},{"path":"/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — extract","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) ... (applicable) stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking)","code":""},{"path":"/reference/extract.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — extract","text":".predict.sta(): called predict.transreg stack=\"sta\" .predict.sim(): called predict.transreg stack=\"sim\" .coef.sta(): called coef.transreg stack=\"sta\" .coef.sim(): called coef.transreg stack=\"sim\" .weights.sta(): called weights.transreg stack=\"sta\" .weights.sim(): called weights.transreg stack=\"sim\" ..stack(): called coef.transreg, predict.transreg weights.transreg","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values — fitted.transreg","title":"Fitted values — fitted.transreg","text":"Extracts fitted values","code":""},{"path":"/reference/fitted.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values — fitted.transreg","text":"","code":"# S3 method for transreg fitted(object, stack = NULL, ...)"},{"path":"/reference/fitted.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values — fitted.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/fitted.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values — fitted.transreg","text":"Returns fitted values. output numerical vector one entry sample.","code":""},{"path":"/reference/fitted.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitted values — fitted.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values — fitted.transreg","text":"","code":"#--- simulation --- set.seed(1) n0 <- 100; n1 <- 10000; n <- n0 + n1; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- train-test split --- foldid <- rep(c(0,1),times=c(n0,n1)) y0 <- y[foldid==0] X0 <- X[foldid==0,] y1 <- y[foldid==1] X1 <- X[foldid==1,]  object <- transreg(y=y0,X=X0,prior=prior)  #--- fitted values --- y0_hat <- fitted(object) mean((y0-y0_hat)^2) #> [1] 112.1512  #--- predicted values --- y1_hat <- predict(object,newx=X1) mean((y1-y1_hat)^2) # increase in MSE? #> [1] 270.4335"},{"path":"/reference/iso.fast.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.fast.single","title":"Isotonic scaling — iso.fast.single","text":"Performs isotonic scaling","code":""},{"path":"/reference/iso.fast.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.fast.single","text":"","code":"iso.fast.single(y, X, prior, family)"},{"path":"/reference/iso.fast.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.fast.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":"/reference/iso.fast.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.fast.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.multiple","title":"Isotonic scaling — iso.multiple","text":"Performs isotonic scaling","code":""},{"path":"/reference/iso.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.multiple","text":"","code":"iso.multiple(y, X, prior, family, select = TRUE, switch = TRUE)"},{"path":"/reference/iso.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical switch choose positive negative weights source: logical","code":""},{"path":"/reference/iso.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.single","title":"Isotonic scaling — iso.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/iso.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.single","text":"","code":"iso.single(y, X, prior, family)"},{"path":"/reference/iso.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.single","text":"y target: vector length \\(n\\) X features: matrix \\(n\\) rows \\(p\\) columns prior prior coefficients: matrix \\(p\\) rows \\(k\\) columns family character \"gaussian\", \"binomial\", \"poisson\"","code":""},{"path":[]},{"path":"/reference/iso.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.slow.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.slow.single","title":"Isotonic scaling — iso.slow.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/iso.slow.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.slow.single","text":"","code":"iso.slow.single(y, X, prior, family)"},{"path":"/reference/iso.slow.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.slow.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/iso.slow.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.slow.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — methods","title":"Internal functions — methods","text":"Internal functions called coef.transreg() predict.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":"/reference/methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — methods","text":"","code":".predict.lp(object, newx, ...)  .predict.mf(object, newx, ...)  .coef.lp(object, ...)  .coef.mf(object, ...)  .which.stack(object, stack)"},{"path":"/reference/methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — methods","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) ... (applicable) stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking)","code":""},{"path":"/reference/methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — methods","text":".predict.lp: called predict.transreg stack=\"lp\" .predict.mf: called predict.transreg stack=\"mf\" .coef.lp: called coef.transreg stack=\"lp\" .coef.mf: called coef.transreg stack=\"mf\" ..stack: called coef.transreg predict.transreg","code":""},{"path":[]},{"path":"/reference/multiridge.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-penalty ridge regression — multiridge","title":"Multi-penalty ridge regression — multiridge","text":"functions can used cross-validate multi-penalty ridge regression (multiridge), extract predicted values (predict.multiridge), extract estimated coefficients (coef.multiridge). full functionality, use R package multiridge.","code":""},{"path":"/reference/multiridge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-penalty ridge regression — multiridge","text":"","code":"multiridge(X, Y, family)  # S3 method for multiridge predict(object, newx, ...)  # S3 method for multiridge coef(object, ...)"},{"path":"/reference/multiridge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-penalty ridge regression — multiridge","text":"X list matrices n rows Y vector length n family character \"gaussian\" \"binomial\" object multiridge-object newx list matrices (new data) ... (applicable)","code":""},{"path":"/reference/multiridge.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multi-penalty ridge regression — multiridge","text":"Mark . van de Wiel , Mirrelijn M. van Nee , Armin Rauschenberger  (2021). \"Fast cross-validation multi-penalty high-dimensional ridge regression\". Journal Computational Graphical Statistics 30(4):835-847. doi:10.1080/10618600.2021.1904962","code":""},{"path":"/reference/multiridge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-penalty ridge regression — multiridge","text":"","code":"# simulation n0 <- 100 # training samples n1 <- 10000 # testing samples n <- n0 + n1 p1 <- 5 # first covariate set p2 <- 500 # second covariate set X1 <- matrix(rnorm(n*p1),nrow=n,ncol=p1) X2 <- matrix(rnorm(n*p2),nrow=n,ncol=p2) beta1 <- rep(c(0,10),times=c(p1-4,4)) beta2 <- c(rnorm(100),rep(0,times=p2-100)) eta <- X2 %*% beta2 + X1 %*% beta1 family <- \"binomial\" # \"gaussian\" or \"binomial\" if(family==\"gaussian\"){  y <- eta } else if(family==\"binomial\"){  y <- round(1/(1+exp(-eta))) } fold <- rep(c(0,1),times=c(n0,n1))  # single penalty glmnet <- glmnet::cv.glmnet(x=cbind(X1[fold==0,],X2[fold==0,]),y=y[fold==0],family=family,alpha=0) y_hat0 <- predict(glmnet,newx=cbind(X1[fold==1,],X2[fold==1,]),s=\"lambda.min\",type=\"response\")  # multiple penalties object <- multiridge(X=list(X1[fold==0,],X2[fold==0,]),Y=y[fold==0],family=family) y_hat1 <- predict(object,newx=list(X1[fold==1,],X2[fold==1,]))  # comparison if(family==\"gaussian\"){ loss0 <- mean((y[fold==1]-y_hat0)^2) loss1 <- mean((y[fold==1]-y_hat1)^2) } else if(family==\"binomial\"){ loss0 <- mean(y[fold==1]!=round(y_hat0)) loss1 <- mean(y[fold==1]!=round(y_hat1)) } loss0 #> [1] 0.4078 loss1 #> [1] 0.1501  # equivalence beta <- coef(object) eta2 <- beta[[1]] + X1[fold==1,] %*% beta[[2]] + X2[fold==1,] %*% beta[[3]] if(family==\"gaussian\"){ y_hat2 <- eta2 } else if(family==\"binomial\"){ y_hat2 <- 1/(1 + exp(-eta2)) } all.equal(y_hat1,y_hat2) #> [1] TRUE"},{"path":"/reference/plot.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot transreg-object — plot.transreg","title":"Plot transreg-object — plot.transreg","text":"Plot transreg-object","code":""},{"path":"/reference/plot.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot transreg-object — plot.transreg","text":"","code":"# S3 method for transreg plot(x, stack = NULL, ...)"},{"path":"/reference/plot.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot transreg-object — plot.transreg","text":"x object type transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/plot.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot transreg-object — plot.transreg","text":"Returns four plots. top-left: Calibrated prior effects (\\(y\\)-axis) original prior effects (\\(x\\)-axis). line one source prior effects, colour given grDevices::palette() (black: 1, red: 2, green: 3, blue: 4, ...). top-right: Estimated coefficients transfer learning (\\(y\\)-axis) estimated coefficients without transfer learning (\\(x\\)-axis). point represents one feature. bottom-left: Estimated weights sources prior effects (labels 1 \\(k\\)), either estimated weights lambda.min lambda.1se models (standard stacking) estimated weights features (simultaneous stacking). bottom-right: Absolute deviance residuals (\\(y\\)-axis) fitted values (\\(x\\)-axis). point represents one sample.","code":""},{"path":"/reference/plot.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot transreg-object — plot.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/plot.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot transreg-object — plot.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) #*rbinom(n=n,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) prior3 <- rnorm(p) prior4 <- rnorm(p) y <- X %*% beta  prior <- cbind(prior1,prior2,prior3,prior4) object <- transreg(y=y,X=X,prior=prior,alpha=0,stack=c(\"sta\",\"sim\"))  plot(object,stack=\"sta\")"},{"path":"/reference/predict.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict — predict.lp","title":"Predict — predict.lp","text":"Predicts outcome","code":""},{"path":"/reference/predict.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict — predict.lp","text":"","code":"# S3 method for lp predict(object, newx, ...)  # S3 method for mf predict(object, newx, ...)"},{"path":"/reference/predict.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict — predict.lp","text":"object object class 'transreg' newx features: matrix m rows (samples) p columns (variables) ... (applicable)","code":""},{"path":"/reference/predict.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict — predict.lp","text":"","code":"NA #> [1] NA"},{"path":"/reference/predict.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Predictions — predict.transreg","title":"Make Predictions — predict.transreg","text":"Predicts outcome","code":""},{"path":"/reference/predict.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Predictions — predict.transreg","text":"","code":"# S3 method for transreg predict(object, newx, stack = NULL, ...)"},{"path":"/reference/predict.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Predictions — predict.transreg","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/predict.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Predictions — predict.transreg","text":"Returns predicted values predicted probabilities. output column vector one entry sample.","code":""},{"path":"/reference/predict.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Make Predictions — predict.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/predict.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make Predictions — predict.transreg","text":"","code":"#--- simulation --- set.seed(1) n0 <- 100; n1 <- 10000; n <- n0 + n1; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- train-test split --- foldid <- rep(c(0,1),times=c(n0,n1)) y0 <- y[foldid==0] X0 <- X[foldid==0,] y1 <- y[foldid==1] X1 <- X[foldid==1,]  #--- glmnet (without prior effects) --- object <- glmnet::cv.glmnet(y=y0,x=X0) y_hat <- predict(object,newx=X1,s=\"lambda.min\") mean((y1-y_hat)^2) #> [1] 493.8406  #--- transreg (with prior effects) --- object <- transreg(y=y0,X=X0,prior=prior) y_hat <- predict(object,newx=X1) mean((y1-y_hat)^2) # decrease in MSE? #> [1] 265.7714"},{"path":"/reference/print.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print transreg-object — print.transreg","title":"Print transreg-object — print.transreg","text":"Show summary transreg-object","code":""},{"path":"/reference/print.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print transreg-object — print.transreg","text":"","code":"# S3 method for transreg print(x, ...)"},{"path":"/reference/print.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print transreg-object — print.transreg","text":"x object class transreg ... (applicable)","code":""},{"path":"/reference/print.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print transreg-object — print.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- beta + rnorm(p) y <- X %*% beta  #--- print.transreg  --- object <- transreg(y=y,X=X,prior=prior) object #> ----- transreg-object ----- #> family: 'gaussian' #> alpha = 1 (lasso) #> n = 100 (samples) #> p = 500 (features) #> k = 1 (sources of co-data) #> calibration: 'iso' #> stacking: 'sim'  #> ---------------------------"},{"path":"/reference/residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — residuals","title":"Calculate residuals — residuals","text":"Calculates residuals observed outcome predicted values (Gaussian family) predicted probabilities (binomial family).","code":""},{"path":"/reference/residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — residuals","text":"","code":"residuals(y, y_hat, family)"},{"path":"/reference/residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — residuals","text":"y response: vector length \\(n\\) (see family) y_hat predicted values probabilities (see family): vector length \\(n\\), matrix \\(n\\) rows (samples) \\(k\\) columns (methods) family character \"gaussian\" (\\(y\\): real numbers, \\(y_hat\\): real numbers) \"binomial\" (\\(y\\): 0s 1s, \\(y_hat\\): unit interval)","code":""},{"path":"/reference/residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate residuals — residuals","text":"","code":"n <- 100 p <- 5 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) #y <- stats::rbinom(n,size=1,prob=0.5) y <- stats::rnorm(n) glm <- glm(y~X,family=\"gaussian\") res <- residuals.glm(glm) y_hat <- predict(glm,type=\"response\") all.equal(res,y-y_hat) #> [1] TRUE"},{"path":"/reference/sign.disc.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign discovery — sign.disc","title":"Sign discovery — sign.disc","text":"Assigns signs prior weights obtain prior coefficients","code":""},{"path":"/reference/sign.disc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign discovery — sign.disc","text":"","code":"# S3 method for disc sign(y, X, prior, family, foldid = NULL, nfolds = 10)"},{"path":"/reference/sign.disc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign discovery — sign.disc","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer","code":""},{"path":"/reference/sign.disc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sign discovery — sign.disc","text":"","code":"n <- 100; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) beta <- stats::rnorm(p)*stats::rbinom(n=p,size=1,prob=0.2) y <- X %*% beta prior <- matrix(abs(beta),ncol=1) #temp <- sign.disc(y,X,prior,family=\"gaussian\") #table(sign(beta),sign(temp))"},{"path":"/reference/simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation (reproducibility) — simulate","title":"Simulation (reproducibility) — simulate","text":"Function reproducing 'internal' simulation study. See vignette.","code":""},{"path":"/reference/simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation (reproducibility) — simulate","text":"","code":"simulate(   p = 1000,   n.target = 100,   n.source = 150,   k = 2,   family = \"gaussian\",   prop = 0.01,   rho.beta = 0.95,   rho.x = 0.95,   w = 0.5,   trans = rep(TRUE, times = k),   exp = rep(1, times = k) )"},{"path":"/reference/simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation (reproducibility) — simulate","text":"p number features n.target sample size target data set n.source sample size(s) source data set(s), scalar vector length k k number source data sets family \"Gaussian\", \"binomial\" \"poisson\" prop approximate proportion features effects rho.beta correlation effects (across different data sets) rho.x base decreasing correlation structure correlation features w weight signal noise trans logical vector length \\(k\\): transferable (TRUE) non-transferable (FALSE) source exp non-negative vector length \\(k\\) transforming beta sign(beta)*abs(beta)^exp","code":""},{"path":[]},{"path":"/reference/simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation (reproducibility) — simulate","text":"","code":"set.seed(1) data <- transreg:::simulate() #> Warning: temporary next line #> This part is temporary! prior <- numeric() for(i in seq_along(data$source)){   glmnet <- glmnet::cv.glmnet(y=data$source[[i]]$y,x=data$source[[i]]$x)   prior <- cbind(prior,coef(glmnet,s=\"lambda.min\")[-1]) } object <- transreg(y=data$target$y,X=data$target$x,prior=prior)"},{"path":"/reference/transreg-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg-package","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"R package transreg implements penalised regression multiple sets prior effects.","code":""},{"path":"/reference/transreg-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Use function transreg() model fitting. Type library(transreg) ?transreg help(\"transreg\") open help file. See vignette examples. Type vignette(\"transreg\") browseVignettes(\"transreg\") open vignette.","code":""},{"path":"/reference/transreg-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":"/reference/transreg-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"","code":"?transreg ?predict.transreg ?coef.transreg"},{"path":"/reference/transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Implements penalised regression multiple sets prior effects","code":""},{"path":"/reference/transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"transreg(   y,   X,   prior,   family = \"gaussian\",   alpha = 1,   foldid = NULL,   nfolds = 10,   scale = \"iso\",   stack = \"sim\",   sign = FALSE,   switch = FALSE,   select = TRUE,   diffpen = FALSE,   track = FALSE,   parallel = FALSE )"},{"path":"/reference/transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalised regression with multiple sets of prior effects — transreg","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer scale character \"exp\" exponential calibration \"iso\" isotonic calibration stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) sign sign discovery procedure: logical (experimental argument) switch choose positive negative weights source: logical select select sources: logical diffpen differential penalisation features meta-features: logical (experimental argument) track show intermediate output (messages plots): logical parallel logical (see cv.glmnet)","code":""},{"path":"/reference/transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Returns object class transreg. Rather accessing slots (see list ), recommended use methods like coef.transreg() predict.transreg(). slot base: Object class glmnet. Regression outcome features (without prior effects), \\(1 + p\\) estimated coefficients (intercept + features). slot meta.sta: NULL object class glmnet. Regression outcome cross-validated linear predictors prior effects estimated effects, \\(1 + k + 2\\) estimated coefficients (intercept + sources co-data + lambda_min lambda_1se). slot meta.sim: NULL object class glmnet. Regression outcome meta-features (cross-validated linear predictors prior effects) original features, \\(1 + k + p\\) estimated coefficients (intercept + sources co-data + features). slot prior.calib: Calibrated prior effects. Matrix \\(p\\) rows \\(k\\) columns. slot data: Original data. List slots y, X prior (see arguments). slot info: Information call. Data frame entries \\(n\\), \\(p\\), \\(k\\), family, alpha, scale stack (see details arguments).","code":""},{"path":"/reference/transreg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg","text":"\\(n\\): sample size \\(p\\): number features \\(k\\): number sources","code":""},{"path":"/reference/transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) weights(one) #> [1] 0.7398149 weights(two) #> [1] 0.7437919 0.3753247  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- standard vs simultaneous stacking --- prior <- c(prior1[1:250],rep(0,250)) sta <- transreg(y=y_lin,X=X,prior=prior,stack=\"sta\") sim <- transreg(y=y_lin,X=X,prior=prior,stack=\"sim\") plot(x=coef(sta$base)[-1],y=coef(sta)$beta)  plot(x=coef(sim$base)[-1],y=coef(sim)$beta)"},{"path":"/reference/weights.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Weights — weights.transreg","title":"Extract Weights — weights.transreg","text":"Extracts weights object class transreg.","code":""},{"path":"/reference/weights.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Weights — weights.transreg","text":"","code":"# S3 method for transreg weights(object, stack = NULL, ...)"},{"path":"/reference/weights.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Weights — weights.transreg","text":"object object class transreg stack character \"sta\" (standard stacking) \"sim\" (simultaneous stacking) ... (applicable)","code":""},{"path":"/reference/weights.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Weights — weights.transreg","text":"Returns weights. output numerical vector one entry source co-data.","code":""},{"path":"/reference/weights.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract Weights — weights.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/weights.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Weights — weights.transreg","text":"","code":"#--- simulation --- set.seed(1) n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p) prior <- cbind(beta+rnorm(p),beta+rnorm(p),rnorm(p),rnorm(p)) y <- X %*% beta  #--- example --- object <- transreg(y=y,X=X,prior=prior) weights(object) #> [1] 0.5647605 0.6181596 0.0000000 0.1233377"},{"path":"/news/index.html","id":"transreg-001-2022-08-04","dir":"Changelog","previous_headings":"","what":"transreg 0.0.1 (2022-08-04)","title":"transreg 0.0.1 (2022-08-04)","text":"first public commit","code":""}]

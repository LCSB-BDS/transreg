[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Armin Rauschenberger. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rauschenberger (2022). transreg: Penalised regression multiple sets prior effects. R package version 0.0.1, https://rauschenberger.github.io/transreg/.","code":"@Manual{,   title = {transreg: Penalised regression with multiple sets of prior effects},   author = {Armin Rauschenberger},   year = {2022},   note = {R package version 0.0.1},   url = {https://rauschenberger.github.io/transreg/}, }"},{"path":"/index.html","id":"penalised-regression-with-multiple-sets-of-prior-effects","dir":"","previous_headings":"","what":"Penalised regression with multiple sets of prior effects","title":"Penalised regression with multiple sets of prior effects","text":"Improves predictive performance ridge lasso regression exploiting one sources prior information importance direction effects.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Penalised regression with multiple sets of prior effects","text":"Install current release CRAN: latest development version GitHub:","code":"#install.packages(\"transreg\") # not yet released! #install.packages(\"remotes\") remotes::install_github(\"rauschenberger/transreg\")"},{"path":"/index.html","id":"reference","dir":"","previous_headings":"","what":"Reference","title":"Penalised regression with multiple sets of prior effects","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). “Penalised regression multiple sets prior effects”. Manuscript preparation.","code":""},{"path":"/reference/calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — calibrate","title":"Internal functions — calibrate","text":"Internal functions called transreg(), depending choice exponential isotonic calibration.","code":""},{"path":"/reference/calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — calibrate","text":"","code":".exp.multiple(y, X, prior, family, select, plot = TRUE)  .iso.slow.single(y, X, prior, family)  .iso.fast.single(y, X, prior, family)  .iso.multiple(y, X, prior, family, select = TRUE, switch = TRUE)"},{"path":"/reference/calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — calibrate","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical plot logical switch choose positive negative weights source: logical","code":""},{"path":"/reference/calibrate.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — calibrate","text":".exp.multiple: called transreg scale=\"iso\" .iso.slow.single: replaced .iso.fast.single .iso.fast.single: called transreg scale=\"iso\" (via .iso.multiple) .iso.multiple: called transreg scale=\"iso\"","code":""},{"path":[]},{"path":"/reference/coef.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients — coef.lp","title":"Coefficients — coef.lp","text":"Extracts coefficients","code":""},{"path":"/reference/coef.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients — coef.lp","text":"","code":"# S3 method for lp coef(object, ...)  # S3 method for mf coef(object, ...)"},{"path":"/reference/coef.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients — coef.lp","text":"object object class 'transreg' ... (applicable)","code":""},{"path":"/reference/coef.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients — coef.lp","text":"","code":"NA #> [1] NA"},{"path":"/reference/coef.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients — coef.transreg","title":"Coefficients — coef.transreg","text":"Extracts coefficients","code":""},{"path":"/reference/coef.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients — coef.transreg","text":"","code":"# S3 method for transreg coef(object, stack = NULL, ...)"},{"path":"/reference/coef.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients — coef.transreg","text":"object object class transreg stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking) ... (applicable)","code":""},{"path":"/reference/coef.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients — coef.transreg","text":"function returns estimated coefficients. output list two slots, namely slot alpha estimated intercept (scalar), slot beta estimated slopes (vector).","code":""},{"path":"/reference/coef.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Coefficients — coef.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/coef.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients — coef.transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) #> p-value (+): 6e-04  #> p-value (-): 0.6  #> + #> p-value (+): 0.00032  #> p-value (-): 0.57  #> + #> p-value (+): 0.00068  #> p-value (-): 0.41  #> + #> p-value (+): 0.0015  #> p-value (-): 0.58  #> + #> p-value (+): 0.0011  #> p-value (-): 0.59  #> + #> p-value (+): 0.00037  #> p-value (-): 0.66  #> + #> p-value (+): 0.0017  #> p-value (-): 0.54  #> + #> p-value (+): 0.0013  #> p-value (-): 0.32  #> + #> p-value (+): 0.007  #> p-value (-): 0.5  #> + #> p-value (+): 0.00051  #> p-value (-): 0.61  #> + #> p-value (+): 0.00034  #> p-value (-): 0.15  #> + two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) #> p-value (+): 0.00059 8.3e-06  #> p-value (-): 0.62 0.64  #> ++ #> p-value (+): 0.00057 6e-05  #> p-value (-): 0.73 0.52  #> ++ #> p-value (+): 0.0024 2.3e-05  #> p-value (-): 0.64 0.53  #> ++ #> p-value (+): 0.00032 2.3e-05  #> p-value (-): 0.41 0.45  #> ++ #> p-value (+): 0.0026 3.5e-05  #> p-value (-): 0.64 0.64  #> ++ #> p-value (+): 0.00057 5.3e-06  #> p-value (-): 0.71 0.72  #> ++ #> p-value (+): 0.0012 6.6e-05  #> p-value (-): 0.44 0.59  #> ++ #> p-value (+): 0.0015 7.3e-05  #> p-value (-): 0.57 0.43  #> ++ #> p-value (+): 0.001 1e-05  #> p-value (-): 0.29 0.62  #> ++ #> p-value (+): 0.00057 3.6e-06  #> p-value (-): 0.46 0.68  #> ++ #> p-value (+): 0.00032 1e-05  #> p-value (-): 0.56 0.59  #> ++ weights(one) #> [1] 0.6340467 weights(two) #> [1] 0.3396805 0.6729642  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") #> p-value (+): 6e-04  #> p-value (-): 0.6  #> + #> p-value (+): 0.00091  #> p-value (-): 0.55  #> + #> p-value (+): 9.9e-05  #> p-value (-): 0.45  #> + #> p-value (+): 0.0011  #> p-value (-): 0.96  #> + #> p-value (+): 0.0019  #> p-value (-): 0.54  #> + #> p-value (+): 0.00036  #> p-value (-): 0.58  #> + #> p-value (+): 0.0024  #> p-value (-): 0.65  #> + #> p-value (+): 0.0021  #> p-value (-): 0.42  #> + #> p-value (+): 0.00096  #> p-value (-): 0.69  #> + #> p-value (+): 0.00091  #> p-value (-): 0.56  #> + #> p-value (+): 0.00092  #> p-value (-): 0.71  #> + log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") #> p-value (+): 2e-05  #> p-value (-): 0.16  #> + #> p-value (+): 4e-06  #> p-value (-): 0.083  #> + #> p-value (+): 0.00012  #> p-value (-): 0.13  #> + #> p-value (+): 3.2e-05  #> p-value (-): 0.17  #> + #> p-value (+): 6.5e-05  #> p-value (-): 0.16  #> + #> p-value (+): 1e-04  #> p-value (-): 0.4  #> + #> p-value (+): 3.3e-05  #> p-value (-): 0.25  #> + #> p-value (+): 4e-05  #> p-value (-): 0.2  #> + #> p-value (+): 1e-05  #> p-value (-): 0.18  #> + #> p-value (+): 5.8e-06  #> p-value (-): 0.089  #> + #> p-value (+): 2.3e-05  #> p-value (-): 0.067  #> + hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) #> p-value (+): 6e-04  #> p-value (-): 0.6  #> + #> p-value (+): 0.0011  #> p-value (-): 0.57  #> + #> p-value (+): 0.00074  #> p-value (-): 0.18  #> + #> p-value (+): 0.0022  #> p-value (-): 0.52  #> + #> p-value (+): 0.00048  #> p-value (-): 0.51  #> + #> p-value (+): 0.00088  #> p-value (-): 0.49  #> + #> p-value (+): 0.0018  #> p-value (-): 0.61  #> + #> p-value (+): 0.00044  #> p-value (-): 0.88  #> + #> p-value (+): 0.00039  #> p-value (-): 0.59  #> + #> p-value (+): 4e-04  #> p-value (-): 0.58  #> + #> p-value (+): 0.0017  #> p-value (-): 0.44  #> + lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) #> p-value (+): 6e-04  #> p-value (-): 0.6  #> + #> p-value (+): 0.0016  #> p-value (-): 0.33  #> + #> p-value (+): 0.0028  #> p-value (-): 0.37  #> + #> p-value (+): 0.00072  #> p-value (-): 0.6  #> + #> p-value (+): 0.00048  #> p-value (-): 0.58  #> + #> p-value (+): 0.0018  #> p-value (-): 0.56  #> + #> p-value (+): 0.0012  #> p-value (-): 0.59  #> + #> p-value (+): 0.00076  #> p-value (-): 0.64  #> + #> p-value (+): 0.00072  #> p-value (-): 0.67  #> + #> p-value (+): 8e-04  #> p-value (-): 0.52  #> + #> p-value (+): 0.00051  #> p-value (-): 0.3  #> + # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") #> p-value (+): 6e-04  #> p-value (-): 0.6  #> + #> p-value (+): 0.0014  #> p-value (-): 0.51  #> + #> p-value (+): 0.0021  #> p-value (-): 0.52  #> + #> p-value (+): 0.0015  #> p-value (-): 0.45  #> + #> p-value (+): 0.0014  #> p-value (-): 0.45  #> + #> p-value (+): 0.001  #> p-value (-): 0.4  #> + #> p-value (+): 0.0011  #> p-value (-): 0.67  #> + #> p-value (+): 0.00073  #> p-value (-): 0.47  #> + #> p-value (+): 0.0013  #> p-value (-): 0.58  #> + #> p-value (+): 0.00063  #> p-value (-): 0.49  #> + #> p-value (+): 0.00013  #> p-value (-): 0.64  #> + plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- linear predictor vs meta-feature stacking --- prior <- c(prior1[1:250],rep(0,250)) lp <- transreg(y=y_lin,X=X,prior=prior,stack=\"lp\") #> p-value (+): 0.027  #> p-value (-): 0.23  #> + #> p-value (+): 0.029  #> p-value (-): 0.22  #> + #> p-value (+): 0.035  #> p-value (-): 0.11  #> + #> p-value (+): 0.037  #> p-value (-): 0.24  #> + #> p-value (+): 0.017  #> p-value (-): 0.26  #> + #> p-value (+): 0.023  #> p-value (-): 0.14  #> + #> p-value (+): 0.061  #> p-value (-): 0.16  #> . #> p-value (+): 0.021  #> p-value (-): 0.25  #> + #> p-value (+): 0.011  #> p-value (-): 0.16  #> + #> p-value (+): 0.0084  #> p-value (-): 0.3  #> + #> p-value (+): 0.041  #> p-value (-): 0.21  #> + mf <- transreg(y=y_lin,X=X,prior=prior,stack=\"mf\") #> p-value (+): 0.027  #> p-value (-): 0.23  #> + #> p-value (+): 0.021  #> p-value (-): 0.16  #> + #> p-value (+): 0.011  #> p-value (-): 0.19  #> + #> p-value (+): 0.032  #> p-value (-): 0.12  #> + #> p-value (+): 0.056  #> p-value (-): 0.12  #> . #> p-value (+): 0.017  #> p-value (-): 0.27  #> + #> p-value (+): 0.084  #> p-value (-): 0.16  #> . #> p-value (+): 0.028  #> p-value (-): 0.28  #> + #> p-value (+): 0.035  #> p-value (-): 0.26  #> + #> p-value (+): 0.019  #> p-value (-): 0.23  #> + #> p-value (+): 0.02  #> p-value (-): 0.14  #> + plot(x=coef(lp$base)[-1],y=coef(lp)$beta)  plot(x=coef(mf$base)[-1],y=coef(mf)$beta)"},{"path":"/reference/compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation — compare","title":"Cross-validation — compare","text":"Performs external \\(k\\)-fold cross-validation estimate predictive performance different methods.","code":""},{"path":"/reference/compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation — compare","text":"","code":"compare(   target,   source = NULL,   prior = NULL,   z = NULL,   family,   alpha,   scale = \"iso\",   sign = FALSE,   select = TRUE,   switch = TRUE,   foldid.ext = NULL,   nfolds.ext = 10,   foldid.int = NULL,   nfolds.int = 10,   type.measure = \"deviance\",   alpha.prior = NULL,   partitions = NULL,   monotone = NULL,   naive = TRUE,   diffpen = FALSE )"},{"path":"/reference/compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation — compare","text":"target list slot x (feature matrix n rows p columns) slot y (target vector length n) source list k lists, slot x (feature matrix m_i rows p columns) slot y (target vector length m_i) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) z prior weights family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 scale character \"exp\" exponential calibration \"iso\" isotonic calibration sign sign discovery procedure: logical select select sources: logical switch choose positive negative weights source: logical foldid.ext external fold identifiers nfolds.ext number external folds foldid.int internal fold identifiers nfolds.int number internal folds type.measure character alpha.prior alpha source regression partitions monotone: GRridge monotone logical naive compare naive transfer learning: logical diffpen differential penalisation features meta-features: logical","code":""},{"path":[]},{"path":"/reference/compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation — compare","text":"","code":"n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) y <- X %*% beta # \\dontshow{ object <- suppressMessages(compare(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0))# } if (FALSE) { object <- compare(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0)}"},{"path":"/reference/cv.transfer.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-validation — cv.transfer","title":"Cross-validation — cv.transfer","text":"Performs external \\(k\\)-fold cross-validation estimate predictive performance different methods.","code":""},{"path":"/reference/cv.transfer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-validation — cv.transfer","text":"","code":"cv.transfer(   target,   source = NULL,   prior = NULL,   z = NULL,   family,   alpha,   scale = \"iso\",   sign = FALSE,   select = TRUE,   switch = TRUE,   foldid.ext = NULL,   nfolds.ext = 10,   foldid.int = NULL,   nfolds.int = 10,   type.measure = \"deviance\",   alpha.prior = NULL,   partitions = NULL,   monotone = NULL,   naive = TRUE,   diffpen = FALSE )"},{"path":"/reference/cv.transfer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-validation — cv.transfer","text":"target list slot x (feature matrix n rows p columns) slot y (target vector length n) source list k lists, slot x (feature matrix m_i rows p columns) slot y (target vector length m_i) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) z prior weights family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 scale character \"exp\" exponential calibration \"iso\" isotonic calibration sign sign discovery procedure: logical select select sources: logical switch choose positive negative weights source: logical foldid.ext external fold identifiers nfolds.ext number external folds foldid.int internal fold identifiers nfolds.int number internal folds type.measure character alpha.prior alpha source regression partitions monotone: GRridge monotone logical naive compare naive transfer learning: logical diffpen differential penalisation features meta-features: logical","code":""},{"path":[]},{"path":"/reference/cv.transfer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-validation — cv.transfer","text":"","code":"n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) y <- X %*% beta # \\dontshow{ object <- suppressMessages(cv.transfer(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0))# } if (FALSE) { object <- cv.transfer(target=list(y=y,x=X),prior=beta,family=\"gaussian\",alpha=0)}"},{"path":"/reference/dot-calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .calibrate","title":"Internal functions — .calibrate","text":"Internal functions called transreg(), depending choice exponential isotonic calibration.","code":""},{"path":"/reference/dot-calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — .calibrate","text":"plot logical","code":""},{"path":[]},{"path":"/reference/dot-coef.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"called by coef.transreg if stack=","title":"called by coef.transreg if stack=","text":"called coef.transreg stack=\"lp\"","code":""},{"path":"/reference/dot-coef.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by coef.transreg if stack=","text":"","code":".coef.lp(object, ...)"},{"path":"/reference/dot-coef.mf.html","id":null,"dir":"Reference","previous_headings":"","what":"called by coef.transreg if stack=","title":"called by coef.transreg if stack=","text":"called coef.transreg stack=\"mf\"","code":""},{"path":"/reference/dot-coef.mf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by coef.transreg if stack=","text":"","code":".coef.mf(object, ...)"},{"path":"/reference/dot-exp.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential scaling — .exp.multiple","title":"Exponential scaling — .exp.multiple","text":"Performs exponential scaling","code":""},{"path":"/reference/dot-exp.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential scaling — .exp.multiple","text":"","code":".exp.multiple(y, X, prior, family, select, plot = TRUE)"},{"path":"/reference/dot-exp.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential scaling — .exp.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical plot logical","code":""},{"path":[]},{"path":"/reference/dot-exp.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential scaling — .exp.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .extract","title":"Internal functions — .extract","text":"Internal functions called coef.transreg(), predict.transreg() weights.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":[]},{"path":"/reference/dot-iso.fast.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.fast.single","title":"Isotonic scaling — .iso.fast.single","text":"Performs isotonic scaling","code":""},{"path":"/reference/dot-iso.fast.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.fast.single","text":"","code":".iso.fast.single(y, X, prior, family)"},{"path":"/reference/dot-iso.fast.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.fast.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/dot-iso.fast.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.fast.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-iso.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.multiple","title":"Isotonic scaling — .iso.multiple","text":"Performs isotonic scaling","code":""},{"path":"/reference/dot-iso.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.multiple","text":"","code":".iso.multiple(y, X, prior, family, select = TRUE, switch = TRUE)"},{"path":"/reference/dot-iso.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical switch choose positive negative weights source: logical","code":""},{"path":[]},{"path":"/reference/dot-iso.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-iso.slow.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — .iso.slow.single","title":"Isotonic scaling — .iso.slow.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/dot-iso.slow.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — .iso.slow.single","text":"","code":".iso.slow.single(y, X, prior, family)"},{"path":"/reference/dot-iso.slow.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — .iso.slow.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/dot-iso.slow.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — .iso.slow.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/dot-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — .methods","title":"Internal functions — .methods","text":"Internal functions called coef.transreg() predict.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":[]},{"path":"/reference/dot-predict.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"called by predict.transreg if stack=","title":"called by predict.transreg if stack=","text":"called predict.transreg stack=\"lp\"","code":""},{"path":"/reference/dot-predict.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by predict.transreg if stack=","text":"","code":".predict.lp(object, newx, ...)"},{"path":"/reference/dot-predict.mf.html","id":null,"dir":"Reference","previous_headings":"","what":"called by predict.transreg if stack=","title":"called by predict.transreg if stack=","text":"called predict.transreg stack=\"mf\"","code":""},{"path":"/reference/dot-predict.mf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"called by predict.transreg if stack=","text":"","code":".predict.mf(object, newx, ...)"},{"path":"/reference/dot-residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — .residuals","title":"Calculate residuals — .residuals","text":"Calculates residuals observed outcome predicted values (Gaussian family) predicted probabilities (binomial family). Called .exp.multiple .iso.multiple.","code":""},{"path":"/reference/dot-residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — .residuals","text":"","code":".residuals(y, y_hat, family)"},{"path":"/reference/dot-residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — .residuals","text":"y response: vector length \\(n\\) (see family) y_hat predicted values probabilities (see family): vector length \\(n\\), matrix \\(n\\) rows (samples) \\(k\\) columns (methods) family character \"gaussian\" (\\(y\\): real numbers, \\(y_hat\\): real numbers) \"binomial\" (\\(y\\): 0s 1s, \\(y_hat\\): unit interval)","code":""},{"path":"/reference/dot-residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate residuals — .residuals","text":"","code":"n <- 100 p <- 5 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) #y <- stats::rbinom(n,size=1,prob=0.5) y <- stats::rnorm(n) glm <- glm(y~X,family=\"gaussian\") res <- residuals.glm(glm) y_hat <- predict(glm,type=\"response\") all.equal(res,y-y_hat) #> [1] TRUE"},{"path":"/reference/dot-signdisc.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign discovery — .signdisc","title":"Sign discovery — .signdisc","text":"Assigns signs prior weights obtain prior coefficients","code":""},{"path":"/reference/dot-signdisc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign discovery — .signdisc","text":"","code":".signdisc(y, X, prior, family, foldid = NULL, nfolds = 10)"},{"path":"/reference/dot-signdisc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign discovery — .signdisc","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer","code":""},{"path":"/reference/dot-signdisc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sign discovery — .signdisc","text":"","code":"n <- 100; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) beta <- stats::rnorm(p)*stats::rbinom(n=p,size=1,prob=0.2) y <- X %*% beta prior <- matrix(abs(beta),ncol=1) #temp <- .signdisc(y,X,prior,family=\"gaussian\") #table(sign(beta),sign(temp))"},{"path":"/reference/dot-simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation — .simulate","title":"Simulation — .simulate","text":"Simulates data","code":""},{"path":"/reference/dot-simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation — .simulate","text":"","code":".simulate(   p = 1000,   n.target = 100,   n.source = 150,   k = 3,   family = \"gaussian\",   prop = 0.01,   rho.beta = 0.95,   rho.x = 0.95,   w = 0.5 )"},{"path":"/reference/dot-simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation — .simulate","text":"p number features n.target sample size target data set n.source sample size(s) source data set(s), scalar vector length k k number source data sets family \"Gaussian\", \"binomial\" \"poisson\" prop approximate proportion features effects rho.beta correlation effects (across different data sets) rho.x base decreasing correlation structure correlation features w weight signal noise","code":""},{"path":"/reference/dot-simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation — .simulate","text":"","code":"NA #> [1] NA"},{"path":"/reference/exp.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential scaling — exp.multiple","title":"Exponential scaling — exp.multiple","text":"Performs exponential scaling","code":""},{"path":"/reference/exp.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential scaling — exp.multiple","text":"","code":"# S3 method for multiple exp(y, X, prior, family, select, plot = TRUE)"},{"path":"/reference/exp.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential scaling — exp.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical plot logical","code":""},{"path":"/reference/exp.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential scaling — exp.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — extract","title":"Internal functions — extract","text":"Internal functions called coef.transreg(), predict.transreg() weights.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":"/reference/extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — extract","text":"","code":".predict.lp(object, newx, ...)  .predict.mf(object, newx, ...)  .coef.lp(object, ...)  .coef.mf(object, ...)  .which.stack(object, stack)  .weights.lp(object, ...)  .weights.mf(object, ...)"},{"path":"/reference/extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — extract","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) ... (applicable) stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking)","code":""},{"path":"/reference/extract.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — extract","text":".predict.lp: called predict.transreg stack=\"lp\" .predict.mf: called predict.transreg stack=\"mf\" .coef.lp: called coef.transreg stack=\"lp\" .coef.mf: called coef.transreg stack=\"mf\" ..stack: called coef.transreg, predict.transreg weights.transreg .weights.lp: called weights.transreg stack=\"lp\" .weights.mf: called weights.transreg stack=\"mf\"","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values — fitted.transreg","title":"Fitted values — fitted.transreg","text":"Extracts fitted values","code":""},{"path":"/reference/fitted.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values — fitted.transreg","text":"","code":"# S3 method for transreg fitted(object, stack = NULL, ...)"},{"path":"/reference/fitted.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values — fitted.transreg","text":"object object class transreg stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking) ... (applicable)","code":""},{"path":"/reference/fitted.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values — fitted.transreg","text":"function returns fitted values. output numerical vector one entry sample.","code":""},{"path":"/reference/fitted.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitted values — fitted.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/fitted.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values — fitted.transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) #> p-value (+): 0.00033  #> p-value (-): 0.7  #> + #> p-value (+): 0.001  #> p-value (-): 0.68  #> + #> p-value (+): 0.00088  #> p-value (-): 0.79  #> + #> p-value (+): 0.00032  #> p-value (-): 0.68  #> + #> p-value (+): 0.0019  #> p-value (-): 0.67  #> + #> p-value (+): 3e-04  #> p-value (-): 0.77  #> + #> p-value (+): 0.00042  #> p-value (-): 0.68  #> + #> p-value (+): 0.00074  #> p-value (-): 0.62  #> + #> p-value (+): 0.0017  #> p-value (-): 0.62  #> + #> p-value (+): 6.6e-05  #> p-value (-): 0.69  #> + #> p-value (+): 0.00025  #> p-value (-): 0.031  #> + two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) #> p-value (+): 0.00087 0.048  #> p-value (-): 0.77 0.15  #> ++ #> p-value (+): 0.0026 0.02  #> p-value (-): 0.91 0.14  #> ++ #> p-value (+): 0.00027 0.031  #> p-value (-): 0.66 0.16  #> ++ #> p-value (+): 0.00018 0.057  #> p-value (-): 0.079 0.18  #> +. #> p-value (+): 0.0033 0.046  #> p-value (-): 0.62 0.12  #> ++ #> p-value (+): 0.0033 0.049  #> p-value (-): 0.69 0.12  #> ++ #> p-value (+): 0.00088 0.032  #> p-value (-): 0.52 0.14  #> ++ #> p-value (+): 0.0019 0.02  #> p-value (-): 0.67 0.16  #> ++ #> p-value (+): 0.00028 0.066  #> p-value (-): 0.71 0.19  #> +. #> p-value (+): 0.006 0.025  #> p-value (-): 0.5 0.14  #> ++ #> p-value (+): 0.00054 0.025  #> p-value (-): 0.68 0.16  #> ++ weights(one) #> [1] 0.8426999 weights(two) #> [1] 0.7220290 0.4389501  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") #> p-value (+): 0.00033  #> p-value (-): 0.7  #> + #> p-value (+): 0.00048  #> p-value (-): 0.77  #> + #> p-value (+): 0.00071  #> p-value (-): 0.61  #> + #> p-value (+): 0.00017  #> p-value (-): 0.73  #> + #> p-value (+): 0.00049  #> p-value (-): 0.82  #> + #> p-value (+): 0.00088  #> p-value (-): 0.64  #> + #> p-value (+): 0.00032  #> p-value (-): 0.71  #> + #> p-value (+): 0.0012  #> p-value (-): 0.68  #> + #> p-value (+): 0.00087  #> p-value (-): 0.055  #> + #> p-value (+): 0.00012  #> p-value (-): 0.72  #> + #> p-value (+): 0.0022  #> p-value (-): 0.69  #> + log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") #> p-value (+): 8.9e-05  #> p-value (-): 1  #> + #> p-value (+): 0.00017  #> p-value (-): 1  #> + #> p-value (+): 0.00011  #> p-value (-): 1  #> + #> p-value (+): 0.00038  #> p-value (-): 0.34  #> + #> p-value (+): 7.8e-06  #> p-value (-): 0.46  #> + #> p-value (+): 2.5e-05  #> p-value (-): 1  #> + #> p-value (+): 0.00054  #> p-value (-): 0.49  #> + #> p-value (+): 0.00039  #> p-value (-): 0.39  #> + #> p-value (+): 4.6e-05  #> p-value (-): 0.51  #> + #> p-value (+): 0.00011  #> p-value (-): 1  #> + #> p-value (+): 9.7e-05  #> p-value (-): 0.51  #> + hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) #> p-value (+): 0.00033  #> p-value (-): 0.7  #> + #> p-value (+): 0.001  #> p-value (-): 0.71  #> + #> p-value (+): 0.00093  #> p-value (-): 0.78  #> + #> p-value (+): 0.00035  #> p-value (-): 0.64  #> + #> p-value (+): 0.00012  #> p-value (-): 0.68  #> + #> p-value (+): 7.8e-05  #> p-value (-): 0.73  #> + #> p-value (+): 0.0031  #> p-value (-): 0.71  #> + #> p-value (+): 0.00017  #> p-value (-): 0.7  #> + #> p-value (+): 0.003  #> p-value (-): 0.59  #> + #> p-value (+): 0.00011  #> p-value (-): 1  #> + #> p-value (+): 0.00084  #> p-value (-): 0.67  #> + lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) #> p-value (+): 0.00033  #> p-value (-): 0.7  #> + #> p-value (+): 0.00072  #> p-value (-): 0.6  #> + #> p-value (+): 0.00044  #> p-value (-): 0.82  #> + #> p-value (+): 9e-04  #> p-value (-): 0.62  #> + #> p-value (+): 0.00011  #> p-value (-): 0.72  #> + #> p-value (+): 0.00053  #> p-value (-): 0.68  #> + #> p-value (+): 0.00084  #> p-value (-): 0.77  #> + #> p-value (+): 0.00083  #> p-value (-): 0.74  #> + #> p-value (+): 1e-04  #> p-value (-): 0.68  #> + #> p-value (+): 7e-04  #> p-value (-): 0.73  #> + #> p-value (+): 0.00064  #> p-value (-): 0.69  #> + # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") #> p-value (+): 0.00033  #> p-value (-): 0.7  #> + #> p-value (+): 0.00025  #> p-value (-): 0.68  #> + #> p-value (+): 0.00078  #> p-value (-): 1  #> + #> p-value (+): 0.00073  #> p-value (-): 0.68  #> + #> p-value (+): 0.002  #> p-value (-): 0.54  #> + #> p-value (+): 0.0018  #> p-value (-): 0.62  #> + #> p-value (+): 1.8e-05  #> p-value (-): 0.36  #> + #> p-value (+): 0.00063  #> p-value (-): 0.089  #> + #> p-value (+): 0.00059  #> p-value (-): 0.68  #> + #> p-value (+): 0.0013  #> p-value (-): 0.72  #> + #> p-value (+): 0.00062  #> p-value (-): 0.59  #> + plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- linear predictor vs meta-feature stacking --- prior <- c(prior1[1:250],rep(0,250)) lp <- transreg(y=y_lin,X=X,prior=prior,stack=\"lp\") #> p-value (+): 0.0096  #> p-value (-): 0.5  #> + #> p-value (+): 0.012  #> p-value (-): 0.46  #> + #> p-value (+): 0.041  #> p-value (-): 0.4  #> + #> p-value (+): 0.028  #> p-value (-): 0.43  #> + #> p-value (+): 0.0019  #> p-value (-): 0.53  #> + #> p-value (+): 0.0047  #> p-value (-): 0.89  #> + #> p-value (+): 0.023  #> p-value (-): 0.33  #> + #> p-value (+): 0.012  #> p-value (-): 0.46  #> + #> p-value (+): 0.013  #> p-value (-): 0.35  #> + #> p-value (+): 0.0087  #> p-value (-): 1  #> + #> p-value (+): 0.012  #> p-value (-): 0.63  #> + mf <- transreg(y=y_lin,X=X,prior=prior,stack=\"mf\") #> p-value (+): 0.0096  #> p-value (-): 0.5  #> + #> p-value (+): 0.0081  #> p-value (-): 0.37  #> + #> p-value (+): 0.0083  #> p-value (-): 0.72  #> + #> p-value (+): 0.0044  #> p-value (-): 0.36  #> + #> p-value (+): 0.023  #> p-value (-): 0.54  #> + #> p-value (+): 0.025  #> p-value (-): 0.7  #> + #> p-value (+): 0.0051  #> p-value (-): 0.7  #> + #> p-value (+): 0.013  #> p-value (-): 0.35  #> + #> p-value (+): 0.011  #> p-value (-): 0.44  #> + #> p-value (+): 0.011  #> p-value (-): 0.45  #> + #> p-value (+): 0.0083  #> p-value (-): 0.47  #> + plot(x=coef(lp$base)[-1],y=coef(lp)$beta)  plot(x=coef(mf$base)[-1],y=coef(mf)$beta)"},{"path":"/reference/iso.fast.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.fast.single","title":"Isotonic scaling — iso.fast.single","text":"Performs isotonic scaling","code":""},{"path":"/reference/iso.fast.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.fast.single","text":"","code":"iso.fast.single(y, X, prior, family)"},{"path":"/reference/iso.fast.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.fast.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":"/reference/iso.fast.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.fast.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.multiple.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.multiple","title":"Isotonic scaling — iso.multiple","text":"Performs isotonic scaling","code":""},{"path":"/reference/iso.multiple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.multiple","text":"","code":"iso.multiple(y, X, prior, family, select = TRUE, switch = TRUE)"},{"path":"/reference/iso.multiple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.multiple","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); select select sources: logical switch choose positive negative weights source: logical","code":""},{"path":"/reference/iso.multiple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.multiple","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.single","title":"Isotonic scaling — iso.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/iso.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.single","text":"","code":"iso.single(y, X, prior, family)"},{"path":"/reference/iso.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.single","text":"y target: vector length \\(n\\) X features: matrix \\(n\\) rows \\(p\\) columns prior prior coefficients: matrix \\(p\\) rows \\(k\\) columns family character \"gaussian\", \"binomial\", \"poisson\"","code":""},{"path":[]},{"path":"/reference/iso.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/iso.slow.single.html","id":null,"dir":"Reference","previous_headings":"","what":"Isotonic scaling — iso.slow.single","title":"Isotonic scaling — iso.slow.single","text":"Performs isotonic scaling. function comparison .","code":""},{"path":"/reference/iso.slow.single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isotonic scaling — iso.slow.single","text":"","code":"iso.slow.single(y, X, prior, family)"},{"path":"/reference/iso.slow.single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isotonic scaling — iso.slow.single","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers);","code":""},{"path":[]},{"path":"/reference/iso.slow.single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isotonic scaling — iso.slow.single","text":"","code":"NA #> [1] NA"},{"path":"/reference/methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — methods","title":"Internal functions — methods","text":"Internal functions called coef.transreg() predict.transreg(), depending choice linear predictor stacking meta-feature stacking.","code":""},{"path":"/reference/methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — methods","text":"","code":".predict.lp(object, newx, ...)  .predict.mf(object, newx, ...)  .coef.lp(object, ...)  .coef.mf(object, ...)  .which.stack(object, stack)"},{"path":"/reference/methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — methods","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) ... (applicable) stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking)","code":""},{"path":"/reference/methods.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Internal functions — methods","text":".predict.lp: called predict.transreg stack=\"lp\" .predict.mf: called predict.transreg stack=\"mf\" .coef.lp: called coef.transreg stack=\"lp\" .coef.mf: called coef.transreg stack=\"mf\" ..stack: called coef.transreg predict.transreg","code":""},{"path":[]},{"path":"/reference/multiridge.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-penalty ridge regression — multiridge","title":"Multi-penalty ridge regression — multiridge","text":"functions can used cross-validate multi-penalty ridge regression (multiridge), extract predicted values (predict.multiridge), extract estimated coefficients (coef.multiridge). full functionality, use R package multiridge.","code":""},{"path":"/reference/multiridge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-penalty ridge regression — multiridge","text":"","code":"multiridge(X, Y, family)  # S3 method for multiridge predict(object, newx, ...)  # S3 method for multiridge coef(object, ...)"},{"path":"/reference/multiridge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-penalty ridge regression — multiridge","text":"X list matrices n rows Y vector length n family character \"gaussian\" \"binomial\" object multiridge-object newx list matrices (new data) ... (applicable)","code":""},{"path":"/reference/multiridge.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multi-penalty ridge regression — multiridge","text":"Mark . van de Wiel , Mirrelijn M. van Nee , Armin Rauschenberger  (2021). \"Fast cross-validation multi-penalty high-dimensional ridge regression\". Journal Computational Graphical Statistics 30(4):835-847. doi:10.1080/10618600.2021.1904962","code":""},{"path":"/reference/multiridge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-penalty ridge regression — multiridge","text":"","code":"# simulation n0 <- 100 # training samples n1 <- 10000 # testing samples n <- n0 + n1 p1 <- 5 # first covariate set p2 <- 500 # second covariate set X1 <- matrix(rnorm(n*p1),nrow=n,ncol=p1) X2 <- matrix(rnorm(n*p2),nrow=n,ncol=p2) beta1 <- rep(c(0,10),times=c(p1-4,4)) beta2 <- c(rnorm(100),rep(0,times=p2-100)) eta <- X2 %*% beta2 + X1 %*% beta1 family <- \"binomial\" # \"gaussian\" or \"binomial\" if(family==\"gaussian\"){  y <- eta } else if(family==\"binomial\"){  y <- round(1/(1+exp(-eta))) } fold <- rep(c(0,1),times=c(n0,n1))  # single penalty glmnet <- glmnet::cv.glmnet(x=cbind(X1[fold==0,],X2[fold==0,]),y=y[fold==0],family=family,alpha=0) y_hat0 <- predict(glmnet,newx=cbind(X1[fold==1,],X2[fold==1,]),s=\"lambda.min\",type=\"response\")  # multiple penalties object <- multiridge(X=list(X1[fold==0,],X2[fold==0,]),Y=y[fold==0],family=family) y_hat1 <- predict(object,newx=list(X1[fold==1,],X2[fold==1,]))  # comparison if(family==\"gaussian\"){ loss0 <- mean((y[fold==1]-y_hat0)^2) loss1 <- mean((y[fold==1]-y_hat1)^2) } else if(family==\"binomial\"){ loss0 <- mean(y[fold==1]!=round(y_hat0)) loss1 <- mean(y[fold==1]!=round(y_hat1)) } loss0 #> [1] 0.3976 loss1 #> [1] 0.1388  # equivalence beta <- coef(object) eta2 <- beta[[1]] + X1[fold==1,] %*% beta[[2]] + X2[fold==1,] %*% beta[[3]] if(family==\"gaussian\"){ y_hat2 <- eta2 } else if(family==\"binomial\"){ y_hat2 <- 1/(1 + exp(-eta2)) } all.equal(y_hat1,y_hat2) #> [1] TRUE"},{"path":"/reference/predict.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict — predict.lp","title":"Predict — predict.lp","text":"Predicts outcome","code":""},{"path":"/reference/predict.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict — predict.lp","text":"","code":"# S3 method for lp predict(object, newx, ...)  # S3 method for mf predict(object, newx, ...)"},{"path":"/reference/predict.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict — predict.lp","text":"object object class 'transreg' newx features: matrix m rows (samples) p columns (variables) ... (applicable)","code":""},{"path":"/reference/predict.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict — predict.lp","text":"","code":"NA #> [1] NA"},{"path":"/reference/predict.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict — predict.transreg","title":"Predict — predict.transreg","text":"Predicts outcome","code":""},{"path":"/reference/predict.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict — predict.transreg","text":"","code":"# S3 method for transreg predict(object, newx, stack = NULL, ...)"},{"path":"/reference/predict.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict — predict.transreg","text":"object object class transreg newx features: matrix \\(n\\) rows (samples) \\(p\\) columns (variables) stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking) ... (applicable)","code":""},{"path":"/reference/predict.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict — predict.transreg","text":"function returns predicted values predicted probabilities. output column vector one entry sample.","code":""},{"path":"/reference/predict.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict — predict.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/predict.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict — predict.transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) #> p-value (+): 9.7e-05  #> p-value (-): 0.62  #> + #> p-value (+): 9e-04  #> p-value (-): 0.53  #> + #> p-value (+): 0.00016  #> p-value (-): 0.68  #> + #> p-value (+): 2e-04  #> p-value (-): 0.56  #> + #> p-value (+): 6.5e-05  #> p-value (-): 0.53  #> + #> p-value (+): 0.00053  #> p-value (-): 0.083  #> + #> p-value (+): 7.2e-05  #> p-value (-): 0.59  #> + #> p-value (+): 0.00023  #> p-value (-): 0.59  #> + #> p-value (+): 0.00029  #> p-value (-): 0.54  #> + #> p-value (+): 5.1e-05  #> p-value (-): 0.64  #> + #> p-value (+): 0.00012  #> p-value (-): 0.69  #> + two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) #> p-value (+): 9.5e-05 8e-04  #> p-value (-): 0.62 0.37  #> ++ #> p-value (+): 0.00012 0.00035  #> p-value (-): 0.64 0.45  #> ++ #> p-value (+): 0.00021 0.0017  #> p-value (-): 0.32 0.32  #> ++ #> p-value (+): 0.00029 0.0052  #> p-value (-): 0.71 0.22  #> ++ #> p-value (+): 0.00029 0.0045  #> p-value (-): 0.59 0.14  #> ++ #> p-value (+): 0.00016 0.002  #> p-value (-): 0.61 0.5  #> ++ #> p-value (+): 6.5e-05 0.0012  #> p-value (-): 0.51 0.46  #> ++ #> p-value (+): 0.00073 0.00084  #> p-value (-): 0.98 0.98  #> ++ #> p-value (+): 2e-04 0.0014  #> p-value (-): 0.55 0.26  #> ++ #> p-value (+): 3.3e-05 0.00044  #> p-value (-): 0.6 0.21  #> ++ #> p-value (+): 0.00032 0.0018  #> p-value (-): 0.54 0.72  #> ++ weights(one) #> [1] 0.7484569 weights(two) #> [1] 0.5395094 0.4210373  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") #> p-value (+): 9.7e-05  #> p-value (-): 0.62  #> + #> p-value (+): 0.00037  #> p-value (-): 0.99  #> + #> p-value (+): 4.6e-05  #> p-value (-): 0.6  #> + #> p-value (+): 4e-04  #> p-value (-): 0.52  #> + #> p-value (+): 8.8e-05  #> p-value (-): 0.73  #> + #> p-value (+): 0.00022  #> p-value (-): 0.54  #> + #> p-value (+): 3.8e-05  #> p-value (-): 0.56  #> + #> p-value (+): 0.00032  #> p-value (-): 0.74  #> + #> p-value (+): 0.00015  #> p-value (-): 0.58  #> + #> p-value (+): 3e-04  #> p-value (-): 0.52  #> + #> p-value (+): 5.6e-05  #> p-value (-): 0.71  #> + log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") #> p-value (+): 2.9e-06  #> p-value (-): 0.25  #> + #> p-value (+): 1.3e-05  #> p-value (-): 0.21  #> + #> p-value (+): 3.8e-06  #> p-value (-): 0.3  #> + #> p-value (+): 4.9e-05  #> p-value (-): 0.49  #> + #> p-value (+): 1.5e-05  #> p-value (-): 0.31  #> + #> p-value (+): 1.8e-05  #> p-value (-): 0.24  #> + #> p-value (+): 2e-06  #> p-value (-): 0.22  #> + #> p-value (+): 2.5e-06  #> p-value (-): 0.3  #> + #> p-value (+): 3.7e-06  #> p-value (-): 0.22  #> + #> p-value (+): 6.7e-07  #> p-value (-): 0.23  #> + #> p-value (+): 5.8e-06  #> p-value (-): 0.15  #> + hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) #> p-value (+): 9.7e-05  #> p-value (-): 0.62  #> + #> p-value (+): 0.00076  #> p-value (-): 0.42  #> + #> p-value (+): 8e-05  #> p-value (-): 0.64  #> + #> p-value (+): 0.00032  #> p-value (-): 0.53  #> + #> p-value (+): 1e-04  #> p-value (-): 0.54  #> + #> p-value (+): 0.00031  #> p-value (-): 0.61  #> + #> p-value (+): 6e-04  #> p-value (-): 0.8  #> + #> p-value (+): 5.6e-05  #> p-value (-): 0.2  #> + #> p-value (+): 6.9e-05  #> p-value (-): 0.61  #> + #> p-value (+): 0.00016  #> p-value (-): 0.6  #> + #> p-value (+): 7.2e-05  #> p-value (-): 0.64  #> + lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) #> p-value (+): 9.7e-05  #> p-value (-): 0.62  #> + #> p-value (+): 0.00077  #> p-value (-): 0.63  #> + #> p-value (+): 8.2e-05  #> p-value (-): 0.53  #> + #> p-value (+): 2e-05  #> p-value (-): 0.6  #> + #> p-value (+): 0.00037  #> p-value (-): 0.57  #> + #> p-value (+): 0.00029  #> p-value (-): 0.57  #> + #> p-value (+): 2.6e-05  #> p-value (-): 0.73  #> + #> p-value (+): 7.2e-05  #> p-value (-): 0.63  #> + #> p-value (+): 6.7e-05  #> p-value (-): 0.64  #> + #> p-value (+): 0.0013  #> p-value (-): 0.6  #> + #> p-value (+): 0.00063  #> p-value (-): 0.58  #> + # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") #> p-value (+): 9.7e-05  #> p-value (-): 0.62  #> + #> p-value (+): 0.00049  #> p-value (-): 0.53  #> + #> p-value (+): 4e-04  #> p-value (-): 0.46  #> + #> p-value (+): 7.5e-05  #> p-value (-): 0.73  #> + #> p-value (+): 0.00022  #> p-value (-): 0.52  #> + #> p-value (+): 2.5e-05  #> p-value (-): 0.46  #> + #> p-value (+): 0.00059  #> p-value (-): 0.68  #> + #> p-value (+): 0.00013  #> p-value (-): 0.54  #> + #> p-value (+): 4.4e-05  #> p-value (-): 0.64  #> + #> p-value (+): 4.8e-05  #> p-value (-): 0.58  #> + #> p-value (+): 0.00019  #> p-value (-): 1  #> + plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- linear predictor vs meta-feature stacking --- prior <- c(prior1[1:250],rep(0,250)) lp <- transreg(y=y_lin,X=X,prior=prior,stack=\"lp\") #> p-value (+): 0.0031  #> p-value (-): 0.5  #> + #> p-value (+): 0.0031  #> p-value (-): 0.32  #> + #> p-value (+): 0.0031  #> p-value (-): 0.47  #> + #> p-value (+): 0.005  #> p-value (-): 0.47  #> + #> p-value (+): 0.0048  #> p-value (-): 0.49  #> + #> p-value (+): 0.0024  #> p-value (-): 0.48  #> + #> p-value (+): 0.003  #> p-value (-): 0.6  #> + #> p-value (+): 0.012  #> p-value (-): 0.48  #> + #> p-value (+): 0.01  #> p-value (-): 0.34  #> + #> p-value (+): 0.0023  #> p-value (-): 0.35  #> + #> p-value (+): 0.011  #> p-value (-): 0.58  #> + mf <- transreg(y=y_lin,X=X,prior=prior,stack=\"mf\") #> p-value (+): 0.0031  #> p-value (-): 0.5  #> + #> p-value (+): 0.0041  #> p-value (-): 0.45  #> + #> p-value (+): 0.0064  #> p-value (-): 0.56  #> + #> p-value (+): 0.003  #> p-value (-): 0.29  #> + #> p-value (+): 0.0011  #> p-value (-): 0.31  #> + #> p-value (+): 0.003  #> p-value (-): 0.43  #> + #> p-value (+): 0.0023  #> p-value (-): 0.7  #> + #> p-value (+): 0.011  #> p-value (-): 0.4  #> + #> p-value (+): 0.003  #> p-value (-): 0.51  #> + #> p-value (+): 0.012  #> p-value (-): 0.51  #> + #> p-value (+): 0.007  #> p-value (-): 0.24  #> + plot(x=coef(lp$base)[-1],y=coef(lp)$beta)  plot(x=coef(mf$base)[-1],y=coef(mf)$beta)"},{"path":"/reference/print.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Print transreg-object — print.transreg","title":"Print transreg-object — print.transreg","text":"Show summary transreg-object","code":""},{"path":"/reference/print.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print transreg-object — print.transreg","text":"","code":"# S3 method for transreg print(x, ...)"},{"path":"/reference/print.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print transreg-object — print.transreg","text":"x object class transreg ... (applicable)","code":""},{"path":"/reference/print.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print transreg-object — print.transreg","text":"","code":"NA #> [1] NA"},{"path":"/reference/residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — residuals","title":"Calculate residuals — residuals","text":"Calculates residuals observed outcome predicted values (Gaussian family) predicted probabilities (binomial family).","code":""},{"path":"/reference/residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — residuals","text":"","code":"residuals(y, y_hat, family)"},{"path":"/reference/residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — residuals","text":"y response: vector length \\(n\\) (see family) y_hat predicted values probabilities (see family): vector length \\(n\\), matrix \\(n\\) rows (samples) \\(k\\) columns (methods) family character \"gaussian\" (\\(y\\): real numbers, \\(y_hat\\): real numbers) \"binomial\" (\\(y\\): 0s 1s, \\(y_hat\\): unit interval)","code":""},{"path":"/reference/residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate residuals — residuals","text":"","code":"n <- 100 p <- 5 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) #y <- stats::rbinom(n,size=1,prob=0.5) y <- stats::rnorm(n) glm <- glm(y~X,family=\"gaussian\") res <- residuals.glm(glm) y_hat <- predict(glm,type=\"response\") all.equal(res,y-y_hat) #> [1] TRUE"},{"path":"/reference/sign.disc.html","id":null,"dir":"Reference","previous_headings":"","what":"Sign discovery — sign.disc","title":"Sign discovery — sign.disc","text":"Assigns signs prior weights obtain prior coefficients","code":""},{"path":"/reference/sign.disc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sign discovery — sign.disc","text":"","code":"# S3 method for disc sign(y, X, prior, family, foldid = NULL, nfolds = 10)"},{"path":"/reference/sign.disc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sign discovery — sign.disc","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer","code":""},{"path":"/reference/sign.disc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sign discovery — sign.disc","text":"","code":"n <- 100; p <- 500 X <- matrix(stats::rnorm(n*p),nrow=n,ncol=p) beta <- stats::rnorm(p)*stats::rbinom(n=p,size=1,prob=0.2) y <- X %*% beta prior <- matrix(abs(beta),ncol=1) #temp <- sign.disc(y,X,prior,family=\"gaussian\") #table(sign(beta),sign(temp))"},{"path":"/reference/simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation — simulate","title":"Simulation — simulate","text":"Simulates data","code":""},{"path":"/reference/simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation — simulate","text":"","code":"simulate(   p = 1000,   n.target = 100,   n.source = 150,   k = 3,   family = \"gaussian\",   prop = 0.01,   rho.beta = 0.95,   rho.x = 0.95,   w = 0.5 )"},{"path":"/reference/simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation — simulate","text":"p number features n.target sample size target data set n.source sample size(s) source data set(s), scalar vector length k k number source data sets family \"Gaussian\", \"binomial\" \"poisson\" prop approximate proportion features effects rho.beta correlation effects (across different data sets) rho.x base decreasing correlation structure correlation features w weight signal noise","code":""},{"path":"/reference/simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation — simulate","text":"","code":"NA #> [1] NA"},{"path":"/reference/transreg-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg-package","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"R package transreg implements penalised regression multiple sets prior effects.","code":""},{"path":"/reference/transreg-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Use function transreg() model fitting. Type library(transreg) ?transreg help(\"transreg\") open help file. See vignette examples. Type vignette(\"transreg\") browseVignettes(\"transreg\") open vignette.","code":""},{"path":"/reference/transreg-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":"/reference/transreg-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg-package","text":"","code":"?transreg ?predict.transreg ?coef.transreg"},{"path":"/reference/transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Penalised regression with multiple sets of prior effects — transreg","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Implements penalised regression multiple sets prior effects","code":""},{"path":"/reference/transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"transreg(   y,   X,   prior,   family = \"gaussian\",   alpha = 1,   foldid = NULL,   nfolds = 10,   scale = \"iso\",   stack = \"mf\",   sign = FALSE,   switch = TRUE,   select = TRUE,   diffpen = FALSE )"},{"path":"/reference/transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Penalised regression with multiple sets of prior effects — transreg","text":"y target: vector length \\(n\\) (see family) X features: matrix \\(n\\) rows (samples) \\(p\\) columns (features) prior prior coefficients: matrix \\(p\\) rows (features) \\(k\\) columns (sources co-data) family character \"gaussian\" (\\(y\\): real numbers), \"binomial\" (\\(y\\): 0s 1s), \"poisson\" (\\(y\\): non-negative integers); alpha elastic net mixing parameter (0=ridge, 1=lasso): number 0 1 foldid fold identifiers: vector length \\(n\\) entries 1 nfolds nfolds number folds: positive integer scale character \"exp\" exponential calibration \"iso\" isotonic calibration stack character \"lp\" linear predictor stacking \"mf\" meta-feature stacking sign sign discovery procedure: logical switch choose positive negative weights source: logical select select sources: logical diffpen differential penalisation features meta-features: logical","code":""},{"path":"/reference/transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Penalised regression with multiple sets of prior effects — transreg","text":"function returns object class transreg. Rather accessing slots (see list ), recommended use methods like predict.transreg coef.transreg. slot base: Object class glmnet. Regression outcome features (without prior effects), \\(1 + p\\) estimated coefficients (intercept + features). slot meta.lp: NULL object class glmnet. Regression outcome cross-validated linear predictors prior effects estimated effects, \\(1 + k + 2\\) estimated coefficients (intercept + sources co-data + lambda_min lambda_1se). slot meta.mf: NULL object class glmnet. Regression outcome meta-features (cross-validated linear predictors prior effects) original features, \\(1 + k + p\\) estimated coefficients (intercept + sources co-data + features). slot scale: indicates chosen calibration approach (\"exp\": exponential calibration, \"iso\": isotonic calibration) slot stack: indicates chosen stacking approach (\"lp\": linear predictor stacking, \"mf\": meta-feature stacking)","code":""},{"path":"/reference/transreg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Penalised regression with multiple sets of prior effects — transreg","text":"\\(n\\): sample size \\(p\\): number features \\(k\\): number sources","code":""},{"path":"/reference/transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Penalised regression with multiple sets of prior effects — transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Penalised regression with multiple sets of prior effects — transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) #> p-value (+): 0.0028  #> p-value (-): 0.23  #> + #> p-value (+): 0.007  #> p-value (-): 0.2  #> + #> p-value (+): 0.0011  #> p-value (-): 0.3  #> + #> p-value (+): 0.0028  #> p-value (-): 0.22  #> + #> p-value (+): 0.0024  #> p-value (-): 0.2  #> + #> p-value (+): 0.0029  #> p-value (-): 0.2  #> + #> p-value (+): 0.014  #> p-value (-): 0.26  #> + #> p-value (+): 0.0087  #> p-value (-): 0.15  #> + #> p-value (+): 0.0053  #> p-value (-): 0.12  #> + #> p-value (+): 0.0034  #> p-value (-): 0.13  #> + #> p-value (+): 0.0017  #> p-value (-): 0.2  #> + two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) #> p-value (+): 0.004 0.00077  #> p-value (-): 0.23 0.49  #> ++ #> p-value (+): 0.0012 0.00073  #> p-value (-): 0.19 0.64  #> ++ #> p-value (+): 0.012 0.00064  #> p-value (-): 0.12 0.42  #> ++ #> p-value (+): 0.0029 0.0043  #> p-value (-): 0.22 0.37  #> ++ #> p-value (+): 0.0022 0.00013  #> p-value (-): 0.25 0.39  #> ++ #> p-value (+): 0.0094 0.0042  #> p-value (-): 0.26 0.6  #> ++ #> p-value (+): 0.0035 0.0017  #> p-value (-): 0.2 0.59  #> ++ #> p-value (+): 0.025 0.0031  #> p-value (-): 0.1 0.58  #> ++ #> p-value (+): 0.0033 0.00053  #> p-value (-): 0.27 0.54  #> ++ #> p-value (+): 0.031 0.0071  #> p-value (-): 0.095 0.29  #> ++ #> p-value (+): 0.0016 0.0013  #> p-value (-): 0.27 0.33  #> ++ weights(one) #> [1] 0.7087297 weights(two) #> [1] 0.4231842 0.5133205  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") #> p-value (+): 0.0028  #> p-value (-): 0.23  #> + #> p-value (+): 0.0017  #> p-value (-): 0.25  #> + #> p-value (+): 0.011  #> p-value (-): 0.16  #> + #> p-value (+): 0.0031  #> p-value (-): 0.19  #> + #> p-value (+): 0.005  #> p-value (-): 0.27  #> + #> p-value (+): 0.0064  #> p-value (-): 0.18  #> + #> p-value (+): 0.0021  #> p-value (-): 0.2  #> + #> p-value (+): 0.023  #> p-value (-): 0.25  #> + #> p-value (+): 0.00097  #> p-value (-): 0.2  #> + #> p-value (+): 0.0035  #> p-value (-): 0.098  #> + #> p-value (+): 0.0043  #> p-value (-): 0.31  #> + log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") #> p-value (+): 4.1e-05  #> p-value (-): 0.089  #> + #> p-value (+): 8e-05  #> p-value (-): 0.066  #> + #> p-value (+): 3.6e-05  #> p-value (-): 0.049  #> + #> p-value (+): 0.00012  #> p-value (-): 0.16  #> + #> p-value (+): 3e-05  #> p-value (-): 0.048  #> + #> p-value (+): 9.3e-05  #> p-value (-): 0.087  #> + #> p-value (+): 4.3e-05  #> p-value (-): 0.034  #> + #> p-value (+): 6.2e-05  #> p-value (-): 0.069  #> + #> p-value (+): 6e-06  #> p-value (-): 0.24  #> + #> p-value (+): 1.4e-05  #> p-value (-): 0.11  #> + #> p-value (+): 8.8e-05  #> p-value (-): 0.11  #> + hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) #> p-value (+): 0.0028  #> p-value (-): 0.23  #> + #> p-value (+): 0.0035  #> p-value (-): 0.21  #> + #> p-value (+): 0.0048  #> p-value (-): 0.14  #> + #> p-value (+): 0.011  #> p-value (-): 0.32  #> + #> p-value (+): 0.0023  #> p-value (-): 0.31  #> + #> p-value (+): 0.0033  #> p-value (-): 0.12  #> + #> p-value (+): 0.0014  #> p-value (-): 0.16  #> + #> p-value (+): 0.0041  #> p-value (-): 0.11  #> + #> p-value (+): 0.0027  #> p-value (-): 0.18  #> + #> p-value (+): 0.0081  #> p-value (-): 0.33  #> + #> p-value (+): 0.0037  #> p-value (-): 0.16  #> + lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) #> p-value (+): 0.0028  #> p-value (-): 0.23  #> + #> p-value (+): 0.00047  #> p-value (-): 0.25  #> + #> p-value (+): 0.0032  #> p-value (-): 0.11  #> + #> p-value (+): 0.00039  #> p-value (-): 0.16  #> + #> p-value (+): 0.0051  #> p-value (-): 0.23  #> + #> p-value (+): 0.015  #> p-value (-): 0.38  #> + #> p-value (+): 0.0021  #> p-value (-): 0.27  #> + #> p-value (+): 0.0031  #> p-value (-): 0.27  #> + #> p-value (+): 0.018  #> p-value (-): 0.1  #> + #> p-value (+): 0.0062  #> p-value (-): 0.17  #> + #> p-value (+): 0.0055  #> p-value (-): 0.13  #> + # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") #> +  #> .  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") #> p-value (+): 0.0028  #> p-value (-): 0.23  #> + #> p-value (+): 0.0025  #> p-value (-): 0.16  #> + #> p-value (+): 0.0036  #> p-value (-): 0.38  #> + #> p-value (+): 0.0066  #> p-value (-): 0.13  #> + #> p-value (+): 0.004  #> p-value (-): 0.19  #> + #> p-value (+): 0.0064  #> p-value (-): 0.33  #> + #> p-value (+): 0.0053  #> p-value (-): 0.19  #> + #> p-value (+): 0.0064  #> p-value (-): 0.2  #> + #> p-value (+): 0.001  #> p-value (-): 0.29  #> + #> p-value (+): 0.0045  #> p-value (-): 0.088  #> + #> p-value (+): 0.00096  #> p-value (-): 0.26  #> + plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- linear predictor vs meta-feature stacking --- prior <- c(prior1[1:250],rep(0,250)) lp <- transreg(y=y_lin,X=X,prior=prior,stack=\"lp\") #> p-value (+): 0.00058  #> p-value (-): 0.88  #> + #> p-value (+): 0.00027  #> p-value (-): 1  #> + #> p-value (+): 0.00027  #> p-value (-): 0.84  #> + #> p-value (+): 0.0014  #> p-value (-): 1  #> + #> p-value (+): 0.0026  #> p-value (-): 0.6  #> + #> p-value (+): 0.00059  #> p-value (-): 1  #> + #> p-value (+): 0.0051  #> p-value (-): 0.7  #> + #> p-value (+): 0.0011  #> p-value (-): 0.22  #> + #> p-value (+): 0.00062  #> p-value (-): 0.2  #> + #> p-value (+): 0.001  #> p-value (-): 0.34  #> + #> p-value (+): 0.00048  #> p-value (-): 0.82  #> + mf <- transreg(y=y_lin,X=X,prior=prior,stack=\"mf\") #> p-value (+): 0.00058  #> p-value (-): 0.88  #> + #> p-value (+): 0.00016  #> p-value (-): 0.13  #> + #> p-value (+): 0.0013  #> p-value (-): 0.97  #> + #> p-value (+): 0.0018  #> p-value (-): 0.12  #> + #> p-value (+): 0.0042  #> p-value (-): 0.76  #> + #> p-value (+): 0.0017  #> p-value (-): 0.094  #> + #> p-value (+): 0.00099  #> p-value (-): 0.63  #> + #> p-value (+): 0.00074  #> p-value (-): 0.55  #> + #> p-value (+): 0.0012  #> p-value (-): 0.17  #> + #> p-value (+): 0.00055  #> p-value (-): 0.74  #> + #> p-value (+): 0.00021  #> p-value (-): 0.15  #> + plot(x=coef(lp$base)[-1],y=coef(lp)$beta)  plot(x=coef(mf$base)[-1],y=coef(mf)$beta)"},{"path":"/reference/weights.transreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract weights — weights.transreg","title":"Extract weights — weights.transreg","text":"Extracts weights sources co-data","code":""},{"path":"/reference/weights.transreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract weights — weights.transreg","text":"","code":"# S3 method for transreg weights(object, stack = NULL, ...)"},{"path":"/reference/weights.transreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract weights — weights.transreg","text":"object object class transreg stack character \"lp\" (linear predictor stacking) \"mf\" (meta-feature stacking) ... (applicable)","code":""},{"path":"/reference/weights.transreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract weights — weights.transreg","text":"function returns weights. output numerical vector one entry source co-data.","code":""},{"path":"/reference/weights.transreg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract weights — weights.transreg","text":"Armin Rauschenberger , Zied Landoulsi , Mark van de Wiel , Enrico Glaab  (2022). \"Penalised regression multiple sets prior effects\". Manuscript preparation. armin.rauschenberger@uni.lu","code":""},{"path":[]},{"path":"/reference/weights.transreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract weights — weights.transreg","text":"","code":"#--- simulation --- n <- 100; p <- 500 X <- matrix(rnorm(n=n*p),nrow=n,ncol=p) beta <- rnorm(p)*rbinom(n=p,size=1,prob=0.2) prior1 <- beta + rnorm(p) prior2 <- beta + rnorm(p) y_lin <- X %*% beta y_log <- 1*(y_lin > 0)  #--- single vs multiple priors --- one <- transreg(y=y_lin,X=X,prior=prior1) #> p-value (+): 9.1e-05  #> p-value (-): 0.7  #> + #> p-value (+): 0.00013  #> p-value (-): 0.064  #> + #> p-value (+): 2e-04  #> p-value (-): 0.56  #> + #> p-value (+): 6.9e-05  #> p-value (-): 0.44  #> + #> p-value (+): 5.7e-05  #> p-value (-): 0.2  #> + #> p-value (+): 0.00014  #> p-value (-): 0.36  #> + #> p-value (+): 0.00032  #> p-value (-): 0.86  #> + #> p-value (+): 2.9e-05  #> p-value (-): 0.46  #> + #> p-value (+): 9.3e-05  #> p-value (-): 0.55  #> + #> p-value (+): 0.00018  #> p-value (-): 0.63  #> + #> p-value (+): 0.00026  #> p-value (-): 0.5  #> + two <- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2)) #> p-value (+): 1e-04 0.011  #> p-value (-): 0.56 0.45  #> ++ #> p-value (+): 4.6e-05 0.012  #> p-value (-): 0.047 0.16  #> ++ #> p-value (+): 0.00015 0.0076  #> p-value (-): 0.11 0.44  #> ++ #> p-value (+): 0.00036 0.044  #> p-value (-): 0.45 0.084  #> ++ #> p-value (+): 0.00048 0.0063  #> p-value (-): 0.15 0.39  #> ++ #> p-value (+): 0.00069 0.018  #> p-value (-): 0.55 0.12  #> ++ #> p-value (+): 0.00014 0.015  #> p-value (-): 0.36 0.38  #> ++ #> p-value (+): 0.00015 0.025  #> p-value (-): 0.44 0.18  #> ++ #> p-value (+): 3.9e-05 0.0093  #> p-value (-): 0.38 0.36  #> ++ #> p-value (+): 2.5e-05 0.0038  #> p-value (-): 0.88 0.19  #> ++ #> p-value (+): 0.00015 0.0056  #> p-value (-): 0.49 0.48  #> ++ weights(one) #> [1] 0.9015527 weights(two) #> [1] 0.7944423 0.1979532  #--- linear vs logistic regression --- lin <- transreg(y=y_lin,X=X,prior=prior1,family=\"gaussian\") #> p-value (+): 9.1e-05  #> p-value (-): 0.7  #> + #> p-value (+): 1.8e-05  #> p-value (-): 0.19  #> + #> p-value (+): 2.7e-05  #> p-value (-): 0.023  #> + #> p-value (+): 0.00072  #> p-value (-): 0.14  #> + #> p-value (+): 0.00054  #> p-value (-): 0.9  #> + #> p-value (+): 1.8e-05  #> p-value (-): 0.49  #> + #> p-value (+): 0.00038  #> p-value (-): 0.42  #> + #> p-value (+): 4.7e-05  #> p-value (-): 0.56  #> + #> p-value (+): 0.00027  #> p-value (-): 0.25  #> + #> p-value (+): 0.00027  #> p-value (-): 0.53  #> + #> p-value (+): 8.7e-05  #> p-value (-): 0.47  #> + log <- transreg(y=y_log,X=X,prior=prior1,family=\"binomial\") #> p-value (+): 1.5e-08  #> p-value (-): 0.37  #> + #> p-value (+): 1.1e-08  #> p-value (-): 0.23  #> + #> p-value (+): 6.5e-07  #> p-value (-): 0.25  #> + #> p-value (+): 6.1e-07  #> p-value (-): 0.48  #> + #> p-value (+): 2.9e-08  #> p-value (-): 1  #> + #> p-value (+): 3.9e-08  #> p-value (-): 0.25  #> + #> p-value (+): 1.4e-07  #> p-value (-): 0.19  #> + #> p-value (+): 7.7e-08  #> p-value (-): 0.37  #> + #> p-value (+): 2.8e-08  #> p-value (-): 1.4e-06  #> + #> p-value (+): 6e-08  #> p-value (-): 0.33  #> + #> p-value (+): 4.5e-09  #> p-value (-): 1.4e-06  #> + hist(predict(lin,newx=X)) # predicted values  hist(predict(log,newx=X)) # predicted probabilities   #--- ridge vs lasso penalisation --- ridge <- transreg(y=y_lin,X=X,prior=prior1,alpha=0) #> p-value (+): 9.1e-05  #> p-value (-): 0.7  #> + #> p-value (+): 1e-05  #> p-value (-): 0.76  #> + #> p-value (+): 7.3e-05  #> p-value (-): 0.41  #> + #> p-value (+): 0.00041  #> p-value (-): 0.5  #> + #> p-value (+): 0.00073  #> p-value (-): 0.73  #> + #> p-value (+): 9.3e-05  #> p-value (-): 0.47  #> + #> p-value (+): 0.00012  #> p-value (-): 0.47  #> + #> p-value (+): 0.00011  #> p-value (-): 0.47  #> + #> p-value (+): 5e-05  #> p-value (-): 0.32  #> + #> p-value (+): 0.00052  #> p-value (-): 0.99  #> + #> p-value (+): 9e-05  #> p-value (-): 0.45  #> + lasso <- transreg(y=y_lin,X=X,prior=prior1,alpha=1) #> p-value (+): 9.1e-05  #> p-value (-): 0.7  #> + #> p-value (+): 0.00035  #> p-value (-): 0.24  #> + #> p-value (+): 0.00059  #> p-value (-): 0.93  #> + #> p-value (+): 0.00069  #> p-value (-): 0.77  #> + #> p-value (+): 6.9e-05  #> p-value (-): 0.47  #> + #> p-value (+): 2.2e-05  #> p-value (-): 0.35  #> + #> p-value (+): 0.00014  #> p-value (-): 0.38  #> + #> p-value (+): 8.2e-05  #> p-value (-): 0.43  #> + #> p-value (+): 0.00011  #> p-value (-): 0.54  #> + #> p-value (+): 6.2e-05  #> p-value (-): 0.33  #> + #> p-value (+): 5.7e-05  #> p-value (-): 0.36  #> + # initial coefficients (without prior) plot(x=coef(ridge$base)[-1]) # dense  plot(x=coef(lasso$base)[-1]) # sparse  # final coefficients (with prior) plot(x=coef(ridge)$beta) # dense  plot(x=coef(lasso)$beta) # not sparse   #--- exponential vs isotonic calibration --- exp <- transreg(y=y_lin,X=X,prior=prior1,scale=\"exp\") #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  #> +  iso <- transreg(y=y_lin,X=X,prior=prior1,scale=\"iso\") #> p-value (+): 9.1e-05  #> p-value (-): 0.7  #> + #> p-value (+): 9.3e-05  #> p-value (-): 0.48  #> + #> p-value (+): 0.00011  #> p-value (-): 1  #> + #> p-value (+): 0.00063  #> p-value (-): 0.8  #> + #> p-value (+): 0.00071  #> p-value (-): 0.78  #> + #> p-value (+): 0.00018  #> p-value (-): 0.46  #> + #> p-value (+): 1.8e-05  #> p-value (-): 0.5  #> + #> p-value (+): 5.4e-05  #> p-value (-): 0.5  #> + #> p-value (+): 0.00012  #> p-value (-): 0.39  #> + #> p-value (+): 1.7e-05  #> p-value (-): 0.084  #> + #> p-value (+): 0.00047  #> p-value (-): 0.083  #> + plot(x=prior1,y=exp$prior.calib)  plot(x=prior1,y=iso$prior.calib)   #--- linear predictor vs meta-feature stacking --- prior <- c(prior1[1:250],rep(0,250)) lp <- transreg(y=y_lin,X=X,prior=prior,stack=\"lp\") #> p-value (+): 0.0034  #> p-value (-): 0.59  #> + #> p-value (+): 0.017  #> p-value (-): 0.67  #> + #> p-value (+): 0.011  #> p-value (-): 0.52  #> + #> p-value (+): 0.0031  #> p-value (-): 0.57  #> + #> p-value (+): 0.005  #> p-value (-): 0.54  #> + #> p-value (+): 0.0054  #> p-value (-): 0.77  #> + #> p-value (+): 0.006  #> p-value (-): 0.48  #> + #> p-value (+): 0.00097  #> p-value (-): 0.29  #> + #> p-value (+): 0.0027  #> p-value (-): 0.6  #> + #> p-value (+): 0.0015  #> p-value (-): 0.28  #> + #> p-value (+): 0.004  #> p-value (-): 0.41  #> + mf <- transreg(y=y_lin,X=X,prior=prior,stack=\"mf\") #> p-value (+): 0.0034  #> p-value (-): 0.59  #> + #> p-value (+): 0.0015  #> p-value (-): 0.88  #> + #> p-value (+): 0.0068  #> p-value (-): 0.26  #> + #> p-value (+): 0.0032  #> p-value (-): 0.54  #> + #> p-value (+): 0.0042  #> p-value (-): 0.65  #> + #> p-value (+): 0.0025  #> p-value (-): 0.63  #> + #> p-value (+): 0.0041  #> p-value (-): 0.48  #> + #> p-value (+): 0.0012  #> p-value (-): 0.51  #> + #> p-value (+): 0.0021  #> p-value (-): 0.58  #> + #> p-value (+): 0.0088  #> p-value (-): 0.5  #> + #> p-value (+): 0.003  #> p-value (-): 0.6  #> + plot(x=coef(lp$base)[-1],y=coef(lp)$beta)  plot(x=coef(mf$base)[-1],y=coef(mf)$beta)"},{"path":"/news/index.html","id":"transreg-001-2022-08-04","dir":"Changelog","previous_headings":"","what":"transreg 0.0.1 (2022-08-04)","title":"transreg 0.0.1 (2022-08-04)","text":"first public commit","code":""}]
